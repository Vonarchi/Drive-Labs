"use strict";exports.id=521,exports.ids=[521],exports.modules={7277:(r,n,a)=>{let s=a(2081),l=a(4290),d=a(8993);function spawn(r,n,a){let u=l(r,n,a),p=s.spawn(u.command,u.args,u.options);return d.hookChildProcess(p,u),p}function spawnSync(r,n,a){let u=l(r,n,a),p=s.spawnSync(u.command,u.args,u.options);return p.error=p.error||d.verifyENOENTSync(p.status,u),p}r.exports=spawn,r.exports.spawn=spawn,r.exports.sync=spawnSync,r.exports._parse=l,r.exports._enoent=d},8993:r=>{let n="win32"===process.platform;function notFoundError(r,n){return Object.assign(Error(`${n} ${r.command} ENOENT`),{code:"ENOENT",errno:"ENOENT",syscall:`${n} ${r.command}`,path:r.command,spawnargs:r.args})}function hookChildProcess(r,a){if(!n)return;let s=r.emit;r.emit=function(n,l){if("exit"===n){let n=verifyENOENT(l,a);if(n)return s.call(r,"error",n)}return s.apply(r,arguments)}}function verifyENOENT(r,a){return n&&1===r&&!a.file?notFoundError(a.original,"spawn"):null}function verifyENOENTSync(r,a){return n&&1===r&&!a.file?notFoundError(a.original,"spawnSync"):null}r.exports={hookChildProcess,verifyENOENT,verifyENOENTSync,notFoundError}},4290:(r,n,a)=>{let s=a(1017),l=a(3338),d=a(2661),u=a(4083),p="win32"===process.platform,m=/\.(?:com|exe)$/i,f=/node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;function detectShebang(r){r.file=l(r);let n=r.file&&u(r.file);return n?(r.args.unshift(r.file),r.command=n,l(r)):r.file}function parseNonShell(r){if(!p)return r;let n=detectShebang(r),a=!m.test(n);if(r.options.forceShell||a){let a=f.test(n);r.command=s.normalize(r.command),r.command=d.command(r.command),r.args=r.args.map(r=>d.argument(r,a));let l=[r.command].concat(r.args).join(" ");r.args=["/d","/s","/c",`"${l}"`],r.command=process.env.comspec||"cmd.exe",r.options.windowsVerbatimArguments=!0}return r}function parse(r,n,a){n&&!Array.isArray(n)&&(a=n,n=null),n=n?n.slice(0):[],a=Object.assign({},a);let s={command:r,args:n,options:a,file:void 0,original:{command:r,args:n}};return a.shell?s:parseNonShell(s)}r.exports=parse},2661:r=>{let n=/([()\][%!^"`<>&|;, *?])/g;function escapeCommand(r){return r=r.replace(n,"^$1")}function escapeArgument(r,a){return r=(r=(r=`${r}`).replace(/(?=(\\+?)?)\1"/g,'$1$1\\"')).replace(/(?=(\\+?)?)\1$/,"$1$1"),r=(r=`"${r}"`).replace(n,"^$1"),a&&(r=r.replace(n,"^$1")),r}r.exports.command=escapeCommand,r.exports.argument=escapeArgument},4083:(r,n,a)=>{let s=a(7147),l=a(1172);function readShebang(r){let n;let a=Buffer.alloc(150);try{n=s.openSync(r,"r"),s.readSync(n,a,0,150,0),s.closeSync(n)}catch(r){}return l(a.toString())}r.exports=readShebang},3338:(r,n,a)=>{let s=a(1017),l=a(9200),d=a(7864);function resolveCommandAttempt(r,n){let a;let u=r.options.env||process.env,p=process.cwd(),m=null!=r.options.cwd,f=m&&void 0!==process.chdir&&!process.chdir.disabled;if(f)try{process.chdir(r.options.cwd)}catch(r){}try{a=l.sync(r.command,{path:u[d({env:u})],pathExt:n?s.delimiter:void 0})}catch(r){}finally{f&&process.chdir(p)}return a&&(a=s.resolve(m?r.options.cwd:"",a)),a}function resolveCommand(r){return resolveCommandAttempt(r)||resolveCommandAttempt(r,!0)}r.exports=resolveCommand},4664:(r,n,a)=>{var s;function isexe(r,n,a){if("function"==typeof n&&(a=n,n={}),!a){if("function"!=typeof Promise)throw TypeError("callback not provided");return new Promise(function(a,s){isexe(r,n||{},function(r,n){r?s(r):a(n)})})}s(r,n||{},function(r,s){r&&("EACCES"===r.code||n&&n.ignoreErrors)&&(r=null,s=!1),a(r,s)})}function sync(r,n){try{return s.sync(r,n||{})}catch(r){if(n&&n.ignoreErrors||"EACCES"===r.code)return!1;throw r}}a(7147),s=a("win32"===process.platform||global.TESTING_WINDOWS?6594:4e3),r.exports=isexe,isexe.sync=sync},4e3:(r,n,a)=>{r.exports=isexe,isexe.sync=sync;var s=a(7147);function isexe(r,n,a){s.stat(r,function(r,s){a(r,!r&&checkStat(s,n))})}function sync(r,n){return checkStat(s.statSync(r),n)}function checkStat(r,n){return r.isFile()&&checkMode(r,n)}function checkMode(r,n){var a=r.mode,s=r.uid,l=r.gid,d=void 0!==n.uid?n.uid:process.getuid&&process.getuid(),u=void 0!==n.gid?n.gid:process.getgid&&process.getgid(),p=parseInt("100",8),m=parseInt("010",8);return a&parseInt("001",8)||a&m&&l===u||a&p&&s===d||a&(p|m)&&0===d}},6594:(r,n,a)=>{r.exports=isexe,isexe.sync=sync;var s=a(7147);function checkPathExt(r,n){var a=void 0!==n.pathExt?n.pathExt:process.env.PATHEXT;if(!a||-1!==(a=a.split(";")).indexOf(""))return!0;for(var s=0;s<a.length;s++){var l=a[s].toLowerCase();if(l&&r.substr(-l.length).toLowerCase()===l)return!0}return!1}function checkStat(r,n,a){return!!(r.isSymbolicLink()||r.isFile())&&checkPathExt(n,a)}function isexe(r,n,a){s.stat(r,function(s,l){a(s,!s&&checkStat(l,r,n))})}function sync(r,n){return checkStat(s.statSync(r),r,n)}},7864:r=>{let pathKey=(r={})=>{let n=r.env||process.env,a=r.platform||process.platform;return"win32"!==a?"PATH":Object.keys(n).reverse().find(r=>"PATH"===r.toUpperCase())||"Path"};r.exports=pathKey,r.exports.default=pathKey},1172:(r,n,a)=>{let s=a(1550);r.exports=(r="")=>{let n=r.match(s);if(!n)return null;let[a,l]=n[0].replace(/#! ?/,"").split(" "),d=a.split("/").pop();return"env"===d?l:l?`${d} ${l}`:d}},1550:r=>{r.exports=/^#!(.*)/},9200:(r,n,a)=>{let s="win32"===process.platform||"cygwin"===process.env.OSTYPE||"msys"===process.env.OSTYPE,l=a(1017),d=s?";":":",u=a(4664),getNotFoundError=r=>Object.assign(Error(`not found: ${r}`),{code:"ENOENT"}),getPathInfo=(r,n)=>{let a=n.colon||d,l=r.match(/\//)||s&&r.match(/\\/)?[""]:[...s?[process.cwd()]:[],...(n.path||process.env.PATH||"").split(a)],u=s?n.pathExt||process.env.PATHEXT||".EXE;.CMD;.BAT;.COM":"",p=s?u.split(a):[""];return s&&-1!==r.indexOf(".")&&""!==p[0]&&p.unshift(""),{pathEnv:l,pathExt:p,pathExtExe:u}},which=(r,n,a)=>{"function"==typeof n&&(a=n,n={}),n||(n={});let{pathEnv:s,pathExt:d,pathExtExe:p}=getPathInfo(r,n),m=[],step=a=>new Promise((d,u)=>{if(a===s.length)return n.all&&m.length?d(m):u(getNotFoundError(r));let p=s[a],f=/^".*"$/.test(p)?p.slice(1,-1):p,g=l.join(f,r),y=!f&&/^\.[\\\/]/.test(r)?r.slice(0,2)+g:g;d(subStep(y,a,0))}),subStep=(r,a,s)=>new Promise((l,f)=>{if(s===d.length)return l(step(a+1));let g=d[s];u(r+g,{pathExt:p},(d,u)=>{if(!d&&u){if(!n.all)return l(r+g);m.push(r+g)}return l(subStep(r,a,s+1))})});return a?step(0).then(r=>a(null,r),a):step(0)};r.exports=which,which.sync=(r,n)=>{n=n||{};let{pathEnv:a,pathExt:s,pathExtExe:d}=getPathInfo(r,n),p=[];for(let m=0;m<a.length;m++){let f=a[m],g=/^".*"$/.test(f)?f.slice(1,-1):f,y=l.join(g,r),b=!g&&/^\.[\\\/]/.test(r)?r.slice(0,2)+y:y;for(let r=0;r<s.length;r++){let a=b+s[r];try{let r=u.sync(a,{pathExt:d});if(r){if(!n.all)return a;p.push(a)}}catch(r){}}}if(n.all&&p.length)return p;if(n.nothrow)return null;throw getNotFoundError(r)}},6521:(r,n,a)=>{function isPlainObject(r){if("object"!=typeof r||null===r)return!1;let n=Object.getPrototypeOf(r);return(null===n||n===Object.prototype||null===Object.getPrototypeOf(n))&&!(Symbol.toStringTag in r)&&!(Symbol.iterator in r)}a.d(n,{r:()=>tT});var s,l=a(1041);let safeNormalizeFileUrl=(r,n)=>{let a=normalizeFileUrl(normalizeDenoExecPath(r));if("string"!=typeof a)throw TypeError(`${n} must be a string or a file URL: ${a}.`);return a},normalizeDenoExecPath=r=>isDenoExecPath(r)?r.toString():r,isDenoExecPath=r=>"string"!=typeof r&&r&&Object.getPrototypeOf(r)===String.prototype,normalizeFileUrl=r=>r instanceof URL?(0,l.fileURLToPath)(r):r,normalizeParameters=(r,n=[],a={})=>{let s=safeNormalizeFileUrl(r,"First argument"),[l,d]=isPlainObject(n)?[[],n]:[n,a];if(!Array.isArray(l))throw TypeError(`Second argument must be either an array of arguments or an options object: ${l}`);if(l.some(r=>"object"==typeof r&&null!==r))throw TypeError(`Second argument must be an array of strings: ${l}`);let u=l.map(String),p=u.find(r=>r.includes("\x00"));if(void 0!==p)throw TypeError(`Arguments cannot contain null bytes ("\\0"): ${p}`);if(!isPlainObject(d))throw TypeError(`Last argument must be an options object: ${d}`);return[s,u,d]};var d=a(7718),u=a(6915);let{toString:p}=Object.prototype,isArrayBuffer=r=>"[object ArrayBuffer]"===p.call(r),isUint8Array=r=>"[object Uint8Array]"===p.call(r),bufferToUint8Array=r=>new Uint8Array(r.buffer,r.byteOffset,r.byteLength),m=new TextEncoder,stringToUint8Array=r=>m.encode(r),f=new TextDecoder,uint8ArrayToString=r=>f.decode(r),joinToString=(r,n)=>{let a=uint8ArraysToStrings(r,n);return a.join("")},uint8ArraysToStrings=(r,n)=>{if("utf8"===n&&r.every(r=>"string"==typeof r))return r;let a=new u.StringDecoder(n),s=r.map(r=>"string"==typeof r?stringToUint8Array(r):r).map(r=>a.write(r)),l=a.end();return""===l?s:[...s,l]},joinToUint8Array=r=>1===r.length&&isUint8Array(r[0])?r[0]:concatUint8Arrays(stringsToUint8Arrays(r)),stringsToUint8Arrays=r=>r.map(r=>"string"==typeof r?stringToUint8Array(r):r),concatUint8Arrays=r=>{let n=new Uint8Array(getJoinLength(r)),a=0;for(let s of r)n.set(s,a),a+=s.length;return n},getJoinLength=r=>{let n=0;for(let a of r)n+=a.length;return n},isTemplateString=r=>Array.isArray(r)&&Array.isArray(r.raw),parseTemplates=(r,n)=>{let a=[];for(let[s,l]of r.entries())a=parseTemplate({templates:r,expressions:n,tokens:a,index:s,template:l});if(0===a.length)throw TypeError("Template script must not be empty");let[s,...l]=a;return[s,l,{}]},parseTemplate=({templates:r,expressions:n,tokens:a,index:s,template:l})=>{if(void 0===l)throw TypeError(`Invalid backslash sequence: ${r.raw[s]}`);let{nextTokens:d,leadingWhitespaces:u,trailingWhitespaces:p}=splitByWhitespaces(l,r.raw[s]),m=concatTokens(a,d,u);if(s===n.length)return m;let f=n[s],g=Array.isArray(f)?f.map(r=>parseExpression(r)):[parseExpression(f)];return concatTokens(m,g,p)},splitByWhitespaces=(r,n)=>{if(0===n.length)return{nextTokens:[],leadingWhitespaces:!1,trailingWhitespaces:!1};let a=[],s=0,l=g.has(n[0]);for(let l=0,d=0;l<r.length;l+=1,d+=1){let u=n[d];if(g.has(u))s!==l&&a.push(r.slice(s,l)),s=l+1;else if("\\"===u){let r=n[d+1];"\n"===r?(l-=1,d+=1):"u"===r&&"{"===n[d+2]?d=n.indexOf("}",d+3):d+=y[r]??1}}let d=s===r.length;return d||a.push(r.slice(s)),{nextTokens:a,leadingWhitespaces:l,trailingWhitespaces:d}},g=new Set([" ","	","\r","\n"]),y={x:3,u:5},concatTokens=(r,n,a)=>a||0===r.length||0===n.length?[...r,...n]:[...r.slice(0,-1),`${r.at(-1)}${n[0]}`,...n.slice(1)],parseExpression=r=>{let n=typeof r;if("string"===n)return r;if("number"===n)return String(r);if(isPlainObject(r)&&("stdout"in r||"isMaxBuffer"in r))return getSubprocessResult(r);if(r instanceof d.ChildProcess||"[object Promise]"===Object.prototype.toString.call(r))throw TypeError("Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.");throw TypeError(`Unexpected "${n}" in template expression`)},getSubprocessResult=({stdout:r})=>{if("string"==typeof r)return r;if(isUint8Array(r))return uint8ArrayToString(r);if(void 0===r)throw TypeError('Missing result.stdout in template expression. This is probably due to the previous subprocess\' "stdout" option.');throw TypeError(`Unexpected "${typeof r}" stdout in template expression`)};var b=a(7261),S=a(7742);let isStandardStream=r=>w.includes(r),w=[S.stdin,S.stdout,S.stderr],v=["stdin","stdout","stderr"],getStreamName=r=>v[r]??`stdio[${r}]`,normalizeFdSpecificOptions=r=>{let n={...r};for(let a of x)n[a]=normalizeFdSpecificOption(r,a);return n},normalizeFdSpecificOption=(r,n)=>{let a=Array.from({length:getStdioLength(r)+1}),s=normalizeFdSpecificValue(r[n],a,n);return addDefaultValue(s,n)},getStdioLength=({stdio:r})=>Array.isArray(r)?Math.max(r.length,v.length):v.length,normalizeFdSpecificValue=(r,n,a)=>isPlainObject(r)?normalizeOptionObject(r,n,a):n.fill(r),normalizeOptionObject=(r,n,a)=>{for(let s of Object.keys(r).sort(compareFdName))for(let l of parseFdName(s,a,n))n[l]=r[s];return n},compareFdName=(r,n)=>getFdNameOrder(r)<getFdNameOrder(n)?1:-1,getFdNameOrder=r=>"stdout"===r||"stderr"===r?0:"all"===r?2:1,parseFdName=(r,n,a)=>{if("ipc"===r)return[a.length-1];let s=parseFd(r);if(void 0===s||0===s)throw TypeError(`"${n}.${r}" is invalid.
It must be "${n}.stdout", "${n}.stderr", "${n}.all", "${n}.ipc", or "${n}.fd3", "${n}.fd4" (and so on).`);if(s>=a.length)throw TypeError(`"${n}.${r}" is invalid: that file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);return"all"===s?[1,2]:[s]},parseFd=r=>{if("all"===r)return r;if(v.includes(r))return v.indexOf(r);let n=E.exec(r);if(null!==n)return Number(n[1])},E=/^fd(\d+)$/,addDefaultValue=(r,n)=>r.map(r=>void 0===r?T[n]:r),O=(0,b.debuglog)("execa").enabled?"full":"none",T={lines:!1,buffer:!0,maxBuffer:1e8,verbose:O,stripFinalNewline:!0},x=["lines","buffer","maxBuffer","verbose","stripFinalNewline"],getFdSpecificValue=(r,n)=>"ipc"===n?r.at(-1):r[n],isVerbose=({verbose:r},n)=>"none"!==getFdVerbose(r,n),isFullVerbose=({verbose:r},n)=>!["none","short"].includes(getFdVerbose(r,n)),getVerboseFunction=({verbose:r},n)=>{let a=getFdVerbose(r,n);return isVerboseFunction(a)?a:void 0},getFdVerbose=(r,n)=>void 0===n?getFdGenericVerbose(r):getFdSpecificValue(r,n),getFdGenericVerbose=r=>r.find(r=>isVerboseFunction(r))??D.findLast(n=>r.includes(n)),isVerboseFunction=r=>"function"==typeof r,D=["none","short","full"],joinCommand=(r,n)=>{let a=[r,...n],s=a.join(" "),l=a.map(r=>quoteString(escapeControlCharacters(r))).join(" ");return{command:s,escapedCommand:l}},escapeLines=r=>(0,b.stripVTControlCharacters)(r).split("\n").map(r=>escapeControlCharacters(r)).join("\n"),escapeControlCharacters=r=>r.replaceAll(I,r=>escapeControlCharacter(r)),escapeControlCharacter=r=>{let n=A[r];if(void 0!==n)return n;let a=r.codePointAt(0),s=a.toString(16);return a<=M?`\\u${s.padStart(4,"0")}`:`\\U${s}`},I=(()=>{try{return RegExp("\\p{Separator}|\\p{Other}","gu")}catch{return/[\s\u0000-\u001F\u007F-\u009F\u00AD]/g}})(),A={" ":" ","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","	":"\\t"},M=65535,quoteString=r=>F.test(r)?r:"win32"===S.platform?`"${r.replaceAll('"','""')}"`:`'${r.replaceAll("'","'\\''")}'`,F=/^[\w./-]+$/;function isUnicodeSupported(){let{env:r}=S,{TERM:n,TERM_PROGRAM:a}=r;return"win32"!==S.platform?"linux"!==n:!!r.WT_SESSION||!!r.TERMINUS_SUBLIME||"{cmd::Cmder}"===r.ConEmuTask||"Terminus-Sublime"===a||"vscode"===a||"xterm-256color"===n||"alacritty"===n||"rxvt-unicode"===n||"rxvt-unicode-256color"===n||"JetBrains-JediTerm"===r.TERMINAL_EMULATOR}let R={circleQuestionMark:"(?)",questionMarkPrefix:"(?)",square:"█",squareDarkShade:"▓",squareMediumShade:"▒",squareLightShade:"░",squareTop:"▀",squareBottom:"▄",squareLeft:"▌",squareRight:"▐",squareCenter:"■",bullet:"●",dot:"․",ellipsis:"…",pointerSmall:"›",triangleUp:"▲",triangleUpSmall:"▴",triangleDown:"▼",triangleDownSmall:"▾",triangleLeftSmall:"◂",triangleRightSmall:"▸",home:"⌂",heart:"♥",musicNote:"♪",musicNoteBeamed:"♫",arrowUp:"↑",arrowDown:"↓",arrowLeft:"←",arrowRight:"→",arrowLeftRight:"↔",arrowUpDown:"↕",almostEqual:"≈",notEqual:"≠",lessOrEqual:"≤",greaterOrEqual:"≥",identical:"≡",infinity:"∞",subscriptZero:"₀",subscriptOne:"₁",subscriptTwo:"₂",subscriptThree:"₃",subscriptFour:"₄",subscriptFive:"₅",subscriptSix:"₆",subscriptSeven:"₇",subscriptEight:"₈",subscriptNine:"₉",oneHalf:"\xbd",oneThird:"⅓",oneQuarter:"\xbc",oneFifth:"⅕",oneSixth:"⅙",oneEighth:"⅛",twoThirds:"⅔",twoFifths:"⅖",threeQuarters:"\xbe",threeFifths:"⅗",threeEighths:"⅜",fourFifths:"⅘",fiveSixths:"⅚",fiveEighths:"⅝",sevenEighths:"⅞",line:"─",lineBold:"━",lineDouble:"═",lineDashed0:"┄",lineDashed1:"┅",lineDashed2:"┈",lineDashed3:"┉",lineDashed4:"╌",lineDashed5:"╍",lineDashed6:"╴",lineDashed7:"╶",lineDashed8:"╸",lineDashed9:"╺",lineDashed10:"╼",lineDashed11:"╾",lineDashed12:"−",lineDashed13:"–",lineDashed14:"‐",lineDashed15:"⁃",lineVertical:"│",lineVerticalBold:"┃",lineVerticalDouble:"║",lineVerticalDashed0:"┆",lineVerticalDashed1:"┇",lineVerticalDashed2:"┊",lineVerticalDashed3:"┋",lineVerticalDashed4:"╎",lineVerticalDashed5:"╏",lineVerticalDashed6:"╵",lineVerticalDashed7:"╷",lineVerticalDashed8:"╹",lineVerticalDashed9:"╻",lineVerticalDashed10:"╽",lineVerticalDashed11:"╿",lineDownLeft:"┐",lineDownLeftArc:"╮",lineDownBoldLeftBold:"┓",lineDownBoldLeft:"┒",lineDownLeftBold:"┑",lineDownDoubleLeftDouble:"╗",lineDownDoubleLeft:"╖",lineDownLeftDouble:"╕",lineDownRight:"┌",lineDownRightArc:"╭",lineDownBoldRightBold:"┏",lineDownBoldRight:"┎",lineDownRightBold:"┍",lineDownDoubleRightDouble:"╔",lineDownDoubleRight:"╓",lineDownRightDouble:"╒",lineUpLeft:"┘",lineUpLeftArc:"╯",lineUpBoldLeftBold:"┛",lineUpBoldLeft:"┚",lineUpLeftBold:"┙",lineUpDoubleLeftDouble:"╝",lineUpDoubleLeft:"╜",lineUpLeftDouble:"╛",lineUpRight:"└",lineUpRightArc:"╰",lineUpBoldRightBold:"┗",lineUpBoldRight:"┖",lineUpRightBold:"┕",lineUpDoubleRightDouble:"╚",lineUpDoubleRight:"╙",lineUpRightDouble:"╘",lineUpDownLeft:"┤",lineUpBoldDownBoldLeftBold:"┫",lineUpBoldDownBoldLeft:"┨",lineUpDownLeftBold:"┥",lineUpBoldDownLeftBold:"┩",lineUpDownBoldLeftBold:"┪",lineUpDownBoldLeft:"┧",lineUpBoldDownLeft:"┦",lineUpDoubleDownDoubleLeftDouble:"╣",lineUpDoubleDownDoubleLeft:"╢",lineUpDownLeftDouble:"╡",lineUpDownRight:"├",lineUpBoldDownBoldRightBold:"┣",lineUpBoldDownBoldRight:"┠",lineUpDownRightBold:"┝",lineUpBoldDownRightBold:"┡",lineUpDownBoldRightBold:"┢",lineUpDownBoldRight:"┟",lineUpBoldDownRight:"┞",lineUpDoubleDownDoubleRightDouble:"╠",lineUpDoubleDownDoubleRight:"╟",lineUpDownRightDouble:"╞",lineDownLeftRight:"┬",lineDownBoldLeftBoldRightBold:"┳",lineDownLeftBoldRightBold:"┯",lineDownBoldLeftRight:"┰",lineDownBoldLeftBoldRight:"┱",lineDownBoldLeftRightBold:"┲",lineDownLeftRightBold:"┮",lineDownLeftBoldRight:"┭",lineDownDoubleLeftDoubleRightDouble:"╦",lineDownDoubleLeftRight:"╥",lineDownLeftDoubleRightDouble:"╤",lineUpLeftRight:"┴",lineUpBoldLeftBoldRightBold:"┻",lineUpLeftBoldRightBold:"┷",lineUpBoldLeftRight:"┸",lineUpBoldLeftBoldRight:"┹",lineUpBoldLeftRightBold:"┺",lineUpLeftRightBold:"┶",lineUpLeftBoldRight:"┵",lineUpDoubleLeftDoubleRightDouble:"╩",lineUpDoubleLeftRight:"╨",lineUpLeftDoubleRightDouble:"╧",lineUpDownLeftRight:"┼",lineUpBoldDownBoldLeftBoldRightBold:"╋",lineUpDownBoldLeftBoldRightBold:"╈",lineUpBoldDownLeftBoldRightBold:"╇",lineUpBoldDownBoldLeftRightBold:"╊",lineUpBoldDownBoldLeftBoldRight:"╉",lineUpBoldDownLeftRight:"╀",lineUpDownBoldLeftRight:"╁",lineUpDownLeftBoldRight:"┽",lineUpDownLeftRightBold:"┾",lineUpBoldDownBoldLeftRight:"╂",lineUpDownLeftBoldRightBold:"┿",lineUpBoldDownLeftBoldRight:"╃",lineUpBoldDownLeftRightBold:"╄",lineUpDownBoldLeftBoldRight:"╅",lineUpDownBoldLeftRightBold:"╆",lineUpDoubleDownDoubleLeftDoubleRightDouble:"╬",lineUpDoubleDownDoubleLeftRight:"╫",lineUpDownLeftDoubleRightDouble:"╪",lineCross:"╳",lineBackslash:"╲",lineSlash:"╱"},C={tick:"✔",info:"ℹ",warning:"⚠",cross:"✘",squareSmall:"◻",squareSmallFilled:"◼",circle:"◯",circleFilled:"◉",circleDotted:"◌",circleDouble:"◎",circleCircle:"ⓞ",circleCross:"ⓧ",circlePipe:"Ⓘ",radioOn:"◉",radioOff:"◯",checkboxOn:"☒",checkboxOff:"☐",checkboxCircleOn:"ⓧ",checkboxCircleOff:"Ⓘ",pointer:"❯",triangleUpOutline:"△",triangleLeft:"◀",triangleRight:"▶",lozenge:"◆",lozengeOutline:"◇",hamburger:"☰",smiley:"㋡",mustache:"෴",star:"★",play:"▶",nodejs:"⬢",oneSeventh:"⅐",oneNinth:"⅑",oneTenth:"⅒"},P={...R,...C},N={...R,tick:"√",info:"i",warning:"‼",cross:"\xd7",squareSmall:"□",squareSmallFilled:"■",circle:"( )",circleFilled:"(*)",circleDotted:"( )",circleDouble:"( )",circleCircle:"(○)",circleCross:"(\xd7)",circlePipe:"(│)",radioOn:"(*)",radioOff:"( )",checkboxOn:"[\xd7]",checkboxOff:"[ ]",checkboxCircleOn:"(\xd7)",checkboxCircleOff:"( )",pointer:">",triangleUpOutline:"∆",triangleLeft:"◄",triangleRight:"►",lozenge:"♦",lozengeOutline:"◊",hamburger:"≡",smiley:"☺",mustache:"┌─┐",star:"✶",play:"►",nodejs:"♦",oneSeventh:"1/7",oneNinth:"1/9",oneTenth:"1/10"},$=isUnicodeSupported(),B=$?P:N;Object.entries(C);var L=a(5997);let U=L?.WriteStream?.prototype?.hasColors?.()??!1,format=(r,n)=>{if(!U)return r=>r;let a=`\u001B[${r}m`,s=`\u001B[${n}m`;return r=>{let l=r+"",d=l.indexOf(s);if(-1===d)return a+l+s;let u=a,p=0,m=(22===n?s:"")+a;for(;-1!==d;)u+=l.slice(p,d)+m,p=d+s.length,d=l.indexOf(s,p);return u+(l.slice(p)+s)}};format(0,0);let k=format(1,22);format(2,22),format(3,23),format(4,24),format(53,55),format(7,27),format(8,28),format(9,29),format(30,39),format(31,39),format(32,39),format(33,39),format(34,39),format(35,39),format(36,39),format(37,39);let j=format(90,39);format(40,49),format(41,49),format(42,49),format(43,49),format(44,49),format(45,49),format(46,49),format(47,49),format(100,49);let z=format(91,39);format(92,39);let G=format(93,39);format(94,39),format(95,39),format(96,39),format(97,39),format(101,49),format(102,49),format(103,49),format(104,49),format(105,49),format(106,49),format(107,49);let defaultVerboseFunction=({type:r,message:n,timestamp:a,piped:s,commandId:l,result:{failed:d=!1}={},options:{reject:u=!0}})=>{let p=serializeTimestamp(a),m=V[r]({failed:d,reject:u,piped:s}),f=_[r]({reject:u});return`${j(`[${p}]`)} ${j(`[${l}]`)} ${f(m)} ${f(n)}`},serializeTimestamp=r=>`${padField(r.getHours(),2)}:${padField(r.getMinutes(),2)}:${padField(r.getSeconds(),2)}.${padField(r.getMilliseconds(),3)}`,padField=(r,n)=>String(r).padStart(n,"0"),getFinalIcon=({failed:r,reject:n})=>r?n?B.cross:B.warning:B.tick,V={command:({piped:r})=>r?"|":"$",output:()=>" ",ipc:()=>"*",error:getFinalIcon,duration:getFinalIcon},identity=r=>r,_={command:()=>k,output:()=>identity,ipc:()=>identity,error:({reject:r})=>r?z:G,duration:()=>j},applyVerboseOnLines=(r,n,a)=>{let s=getVerboseFunction(n,a);return r.map(({verboseLine:r,verboseObject:n})=>applyVerboseFunction(r,n,s)).filter(r=>void 0!==r).map(r=>appendNewline(r)).join("")},applyVerboseFunction=(r,n,a)=>{if(void 0===a)return r;let s=a(r,n);if("string"==typeof s)return s},appendNewline=r=>r.endsWith("\n")?r:`${r}
`,verboseLog=({type:r,verboseMessage:n,fdNumber:a,verboseInfo:s,result:l})=>{let d=getVerboseObject({type:r,result:l,verboseInfo:s}),u=getPrintedLines(n,d),p=applyVerboseOnLines(u,s,a);""!==p&&console.warn(p.slice(0,-1))},getVerboseObject=({type:r,result:n,verboseInfo:{escapedCommand:a,commandId:s,rawOptions:{piped:l=!1,...d}}})=>({type:r,escapedCommand:a,commandId:`${s}`,timestamp:new Date,piped:l,result:n,options:d}),getPrintedLines=(r,n)=>r.split("\n").map(r=>getPrintedLine({...n,message:r})),getPrintedLine=r=>{let n=defaultVerboseFunction(r);return{verboseLine:n,verboseObject:r}},serializeVerboseMessage=r=>{let n="string"==typeof r?r:(0,b.inspect)(r),a=escapeLines(n);return a.replaceAll("	"," ".repeat(W))},W=2,logCommand=(r,n)=>{isVerbose(n)&&verboseLog({type:"command",verboseMessage:r,verboseInfo:n})},getVerboseInfo=(r,n,a)=>{validateVerbose(r);let s=getCommandId(r);return{verbose:r,escapedCommand:n,commandId:s,rawOptions:a}},getCommandId=r=>isVerbose({verbose:r})?H++:void 0,H=0n,validateVerbose=r=>{for(let n of r){if(!1===n)throw TypeError('The "verbose: false" option was renamed to "verbose: \'none\'".');if(!0===n)throw TypeError('The "verbose: true" option was renamed to "verbose: \'short\'".');if(!D.includes(n)&&!isVerboseFunction(n)){let r=D.map(r=>`'${r}'`).join(", ");throw TypeError(`The "verbose" option must not be ${n}. Allowed values are: ${r} or a function.`)}}},getStartTime=()=>S.hrtime.bigint(),getDurationMs=r=>Number(S.hrtime.bigint()-r)/1e6,handleCommand=(r,n,a)=>{let s=getStartTime(),{command:l,escapedCommand:d}=joinCommand(r,n),u=normalizeFdSpecificOption(a,"verbose"),p=getVerboseInfo(u,d,{...a});return logCommand(d,p),{command:l,escapedCommand:d,startTime:s,verboseInfo:p}};var K=a(9411),q=a(7277);function pathKey(r={}){let{env:n=process.env,platform:a=process.platform}=r;return"win32"!==a?"PATH":Object.keys(n).reverse().find(r=>"PATH"===r.toUpperCase())||"Path"}function toPath(r){return r instanceof URL?(0,l.fileURLToPath)(r):r}function traversePathUp(r){return{*[Symbol.iterator](){let n,a=K.resolve(toPath(r));for(;n!==a;)yield a,n=a,a=K.resolve(a,"..")}}}(0,b.promisify)(d.execFile);let npmRunPath=({cwd:r=S.cwd(),path:n=S.env[pathKey()],preferLocal:a=!0,execPath:s=S.execPath,addExecPath:l=!0}={})=>{let d=K.resolve(toPath(r)),u=[],p=n.split(K.delimiter);return a&&applyPreferLocal(u,p,d),l&&applyExecPath(u,p,s,d),""===n||n===K.delimiter?`${u.join(K.delimiter)}${n}`:[...u,n].join(K.delimiter)},applyPreferLocal=(r,n,a)=>{for(let s of traversePathUp(a)){let a=K.join(s,"node_modules/.bin");n.includes(a)||r.push(a)}},applyExecPath=(r,n,a,s)=>{let l=K.resolve(s,toPath(a),"..");n.includes(l)||r.push(l)},npmRunPathEnv=({env:r=S.env,...n}={})=>{r={...r};let a=pathKey({env:r});return n.path=r[a],r[a]=npmRunPath(n),r};var Y=a(9397);let getFinalError=(r,n,a)=>{let s=a?ExecaSyncError:ExecaError,l=r instanceof DiscardedError?{}:{cause:r};return new s(n,l)};let DiscardedError=class DiscardedError extends Error{};let setErrorName=(r,n)=>{Object.defineProperty(r.prototype,"name",{value:n,writable:!0,enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,Z,{value:!0,writable:!1,enumerable:!1,configurable:!1})},isExecaError=r=>isErrorInstance(r)&&Z in r,Z=Symbol("isExecaError"),isErrorInstance=r=>"[object Error]"===Object.prototype.toString.call(r);let ExecaError=class ExecaError extends Error{};setErrorName(ExecaError,ExecaError.name);let ExecaSyncError=class ExecaSyncError extends Error{};setErrorName(ExecaSyncError,ExecaSyncError.name);var X=a(612);let getRealtimeSignals=()=>Array.from({length:Q-J+1},getRealtimeSignal),getRealtimeSignal=(r,n)=>({name:`SIGRT${n+1}`,number:J+n,action:"terminate",description:"Application-specific signal (realtime)",standard:"posix"}),J=34,Q=64,ee=[{name:"SIGHUP",number:1,action:"terminate",description:"Terminal closed",standard:"posix"},{name:"SIGINT",number:2,action:"terminate",description:"User interruption with CTRL-C",standard:"ansi"},{name:"SIGQUIT",number:3,action:"core",description:"User interruption with CTRL-\\",standard:"posix"},{name:"SIGILL",number:4,action:"core",description:"Invalid machine instruction",standard:"ansi"},{name:"SIGTRAP",number:5,action:"core",description:"Debugger breakpoint",standard:"posix"},{name:"SIGABRT",number:6,action:"core",description:"Aborted",standard:"ansi"},{name:"SIGIOT",number:6,action:"core",description:"Aborted",standard:"bsd"},{name:"SIGBUS",number:7,action:"core",description:"Bus error due to misaligned, non-existing address or paging error",standard:"bsd"},{name:"SIGEMT",number:7,action:"terminate",description:"Command should be emulated but is not implemented",standard:"other"},{name:"SIGFPE",number:8,action:"core",description:"Floating point arithmetic error",standard:"ansi"},{name:"SIGKILL",number:9,action:"terminate",description:"Forced termination",standard:"posix",forced:!0},{name:"SIGUSR1",number:10,action:"terminate",description:"Application-specific signal",standard:"posix"},{name:"SIGSEGV",number:11,action:"core",description:"Segmentation fault",standard:"ansi"},{name:"SIGUSR2",number:12,action:"terminate",description:"Application-specific signal",standard:"posix"},{name:"SIGPIPE",number:13,action:"terminate",description:"Broken pipe or socket",standard:"posix"},{name:"SIGALRM",number:14,action:"terminate",description:"Timeout or timer",standard:"posix"},{name:"SIGTERM",number:15,action:"terminate",description:"Termination",standard:"ansi"},{name:"SIGSTKFLT",number:16,action:"terminate",description:"Stack is empty or overflowed",standard:"other"},{name:"SIGCHLD",number:17,action:"ignore",description:"Child process terminated, paused or unpaused",standard:"posix"},{name:"SIGCLD",number:17,action:"ignore",description:"Child process terminated, paused or unpaused",standard:"other"},{name:"SIGCONT",number:18,action:"unpause",description:"Unpaused",standard:"posix",forced:!0},{name:"SIGSTOP",number:19,action:"pause",description:"Paused",standard:"posix",forced:!0},{name:"SIGTSTP",number:20,action:"pause",description:'Paused using CTRL-Z or "suspend"',standard:"posix"},{name:"SIGTTIN",number:21,action:"pause",description:"Background process cannot read terminal input",standard:"posix"},{name:"SIGBREAK",number:21,action:"terminate",description:"User interruption with CTRL-BREAK",standard:"other"},{name:"SIGTTOU",number:22,action:"pause",description:"Background process cannot write to terminal output",standard:"posix"},{name:"SIGURG",number:23,action:"ignore",description:"Socket received out-of-band data",standard:"bsd"},{name:"SIGXCPU",number:24,action:"core",description:"Process timed out",standard:"bsd"},{name:"SIGXFSZ",number:25,action:"core",description:"File too big",standard:"bsd"},{name:"SIGVTALRM",number:26,action:"terminate",description:"Timeout or timer",standard:"bsd"},{name:"SIGPROF",number:27,action:"terminate",description:"Timeout or timer",standard:"bsd"},{name:"SIGWINCH",number:28,action:"ignore",description:"Terminal window size changed",standard:"bsd"},{name:"SIGIO",number:29,action:"terminate",description:"I/O is available",standard:"other"},{name:"SIGPOLL",number:29,action:"terminate",description:"Watched event",standard:"other"},{name:"SIGINFO",number:29,action:"ignore",description:"Request for process information",standard:"other"},{name:"SIGPWR",number:30,action:"terminate",description:"Device running out of power",standard:"systemv"},{name:"SIGSYS",number:31,action:"core",description:"Invalid system call",standard:"other"},{name:"SIGUNUSED",number:31,action:"terminate",description:"Invalid system call",standard:"other"}],getSignals=()=>{let r=getRealtimeSignals(),n=[...ee,...r].map(normalizeSignal);return n},normalizeSignal=({name:r,number:n,description:a,action:s,forced:l=!1,standard:d})=>{let{signals:{[r]:u}}=X.constants,p=void 0!==u;return{name:r,number:p?u:n,description:a,supported:p,action:s,forced:l,standard:d}},getSignalByName=({name:r,number:n,description:a,supported:s,action:l,forced:d,standard:u})=>[r,{name:r,number:n,description:a,supported:s,action:l,forced:d,standard:u}],et=(()=>{let r=getSignals();return Object.fromEntries(r.map(getSignalByName))})(),getSignalByNumber=(r,n)=>{let a=findSignalByNumber(r,n);if(void 0===a)return{};let{name:s,description:l,supported:d,action:u,forced:p,standard:m}=a;return{[r]:{name:s,number:r,description:l,supported:d,action:u,forced:p,standard:m}}},findSignalByNumber=(r,n)=>{let a=n.find(({name:n})=>X.constants.signals[n]===r);return void 0!==a?a:n.find(n=>n.number===r)};(()=>{let r=getSignals(),n=Array.from({length:Q+1},(n,a)=>getSignalByNumber(a,r));return Object.assign({},...n)})();let normalizeKillSignal=r=>{let n="option `killSignal`";if(0===r)throw TypeError(`Invalid ${n}: 0 cannot be used.`);return signal_normalizeSignal(r,n)},normalizeSignalArgument=r=>0===r?r:signal_normalizeSignal(r,"`subprocess.kill()`'s argument"),signal_normalizeSignal=(r,n)=>{if(Number.isInteger(r))return normalizeSignalInteger(r,n);if("string"==typeof r)return normalizeSignalName(r,n);throw TypeError(`Invalid ${n} ${String(r)}: it must be a string or an integer.
${getAvailableSignals()}`)},normalizeSignalInteger=(r,n)=>{if(er.has(r))return er.get(r);throw TypeError(`Invalid ${n} ${r}: this signal integer does not exist.
${getAvailableSignals()}`)},er=new Map(Object.entries(X.constants.signals).reverse().map(([r,n])=>[n,r])),normalizeSignalName=(r,n)=>{if(r in X.constants.signals)return r;if(r.toUpperCase() in X.constants.signals)throw TypeError(`Invalid ${n} '${r}': please rename it to '${r.toUpperCase()}'.`);throw TypeError(`Invalid ${n} '${r}': this signal name does not exist.
${getAvailableSignals()}`)},getAvailableSignals=()=>`Available signal names: ${getAvailableSignalNames()}.
Available signal numbers: ${getAvailableSignalIntegers()}.`,getAvailableSignalNames=()=>Object.keys(X.constants.signals).sort().map(r=>`'${r}'`).join(", "),getAvailableSignalIntegers=()=>[...new Set(Object.values(X.constants.signals).sort((r,n)=>r-n))].join(", "),getSignalDescription=r=>et[r].description,normalizeForceKillAfterDelay=r=>{if(!1===r)return r;if(!0===r)return en;if(!Number.isFinite(r)||r<0)throw TypeError(`Expected the \`forceKillAfterDelay\` option to be a non-negative integer, got \`${r}\` (${typeof r})`);return r},en=5e3,subprocessKill=({kill:r,options:{forceKillAfterDelay:n,killSignal:a},onInternalError:s,context:l,controller:d},u,p)=>{let{signal:m,error:f}=parseKillArguments(u,p,a);emitKillError(f,s);let g=r(m);return setKillTimeout({kill:r,signal:m,forceKillAfterDelay:n,killSignal:a,killResult:g,context:l,controller:d}),g},parseKillArguments=(r,n,a)=>{let[s=a,l]=isErrorInstance(r)?[void 0,r]:[r,n];if("string"!=typeof s&&!Number.isInteger(s))throw TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(s)}`);if(void 0!==l&&!isErrorInstance(l))throw TypeError(`The second argument is optional. If specified, it must be an error instance: ${l}`);return{signal:normalizeSignalArgument(s),error:l}},emitKillError=(r,n)=>{void 0!==r&&n.reject(r)},setKillTimeout=async({kill:r,signal:n,forceKillAfterDelay:a,killSignal:s,killResult:l,context:d,controller:u})=>{n===s&&l&&killOnTimeout({kill:r,forceKillAfterDelay:a,context:d,controllerSignal:u.signal})},killOnTimeout=async({kill:r,forceKillAfterDelay:n,context:a,controllerSignal:s})=>{if(!1!==n)try{await (0,Y.setTimeout)(n,void 0,{signal:s}),r("SIGKILL")&&(a.isForcefullyTerminated??=!0)}catch{}};var ei=a(5673);let onAbortedSignal=async(r,n)=>{r.aborted||await (0,ei.once)(r,"abort",{signal:n})},validateCancelSignal=({cancelSignal:r})=>{if(void 0!==r&&"[object AbortSignal]"!==Object.prototype.toString.call(r))throw Error(`The \`cancelSignal\` option must be an AbortSignal: ${String(r)}`)},throwOnCancel=({subprocess:r,cancelSignal:n,gracefulCancel:a,context:s,controller:l})=>void 0===n||a?[]:[terminateOnCancel(r,n,s,l)],terminateOnCancel=async(r,n,a,{signal:s})=>{throw await onAbortedSignal(n,s),a.terminationReason??="cancel",r.kill(),n.reason},validateIpcMethod=({methodName:r,isSubprocess:n,ipc:a,isConnected:s})=>{validateIpcOption(r,n,a),validateConnection(r,n,s)},validateIpcOption=(r,n,a)=>{if(!a)throw Error(`${getMethodName(r,n)} can only be used if the \`ipc\` option is \`true\`.`)},validateConnection=(r,n,a)=>{if(!a)throw Error(`${getMethodName(r,n)} cannot be used: the ${getOtherProcessName(n)} has already exited or disconnected.`)},throwOnEarlyDisconnect=r=>{throw Error(`${getMethodName("getOneMessage",r)} could not complete: the ${getOtherProcessName(r)} exited or disconnected.`)},throwOnStrictDeadlockError=r=>{throw Error(`${getMethodName("sendMessage",r)} failed: the ${getOtherProcessName(r)} is sending a message too, instead of listening to incoming messages.
This can be fixed by both sending a message and listening to incoming messages at the same time:

const [receivedMessage] = await Promise.all([
	${getMethodName("getOneMessage",r)},
	${getMethodName("sendMessage",r,"message, {strict: true}")},
]);`)},getStrictResponseError=(r,n)=>Error(`${getMethodName("sendMessage",n)} failed when sending an acknowledgment response to the ${getOtherProcessName(n)}.`,{cause:r}),throwOnMissingStrict=r=>{throw Error(`${getMethodName("sendMessage",r)} failed: the ${getOtherProcessName(r)} is not listening to incoming messages.`)},throwOnStrictDisconnect=r=>{throw Error(`${getMethodName("sendMessage",r)} failed: the ${getOtherProcessName(r)} exited without listening to incoming messages.`)},getAbortDisconnectError=()=>Error(`\`cancelSignal\` aborted: the ${getOtherProcessName(!0)} disconnected.`),throwOnMissingParent=()=>{throw Error("`getCancelSignal()` cannot be used without setting the `cancelSignal` subprocess option.")},handleEpipeError=({error:r,methodName:n,isSubprocess:a})=>{if("EPIPE"===r.code)throw Error(`${getMethodName(n,a)} cannot be used: the ${getOtherProcessName(a)} is disconnecting.`,{cause:r})},handleSerializationError=({error:r,methodName:n,isSubprocess:a,message:s})=>{if(isSerializationError(r))throw Error(`${getMethodName(n,a)}'s argument type is invalid: the message cannot be serialized: ${String(s)}.`,{cause:r})},isSerializationError=({code:r,message:n})=>ea.has(r)||eo.some(r=>n.includes(r)),ea=new Set(["ERR_MISSING_ARGS","ERR_INVALID_ARG_TYPE"]),eo=["could not be cloned","circular structure","call stack size exceeded"],getMethodName=(r,n,a="")=>"cancelSignal"===r?"`cancelSignal`'s `controller.abort()`":`${getNamespaceName(n)}${r}(${a})`,getNamespaceName=r=>r?"":"subprocess.",getOtherProcessName=r=>r?"parent process":"subprocess",disconnect=r=>{r.connected&&r.disconnect()},createDeferred=()=>{let r={},n=new Promise((n,a)=>{Object.assign(r,{resolve:n,reject:a})});return Object.assign(n,r)},getToStream=(r,n="stdin")=>{let{options:a,fileDescriptors:s}=es.get(r),l=getFdNumber(s,n,!0),d=r.stdio[l];if(null===d)throw TypeError(getInvalidStdioOptionMessage(l,n,a,!0));return d},getFromStream=(r,n="stdout")=>{let{options:a,fileDescriptors:s}=es.get(r),l=getFdNumber(s,n,!1),d="all"===l?r.all:r.stdio[l];if(null==d)throw TypeError(getInvalidStdioOptionMessage(l,n,a,!1));return d},es=new WeakMap,getFdNumber=(r,n,a)=>{let s=parseFdNumber(n,a);return validateFdNumber(s,n,a,r),s},parseFdNumber=(r,n)=>{let a=parseFd(r);if(void 0!==a)return a;let{validOptions:s,defaultValue:l}=n?{validOptions:'"stdin"',defaultValue:"stdin"}:{validOptions:'"stdout", "stderr", "all"',defaultValue:"stdout"};throw TypeError(`"${getOptionName(n)}" must not be "${r}".
It must be ${s} or "fd3", "fd4" (and so on).
It is optional and defaults to "${l}".`)},validateFdNumber=(r,n,a,s)=>{let l=s[getUsedDescriptor(r)];if(void 0===l)throw TypeError(`"${getOptionName(a)}" must not be ${n}. That file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);if("input"===l.direction&&!a)throw TypeError(`"${getOptionName(a)}" must not be ${n}. It must be a readable stream, not writable.`);if("input"!==l.direction&&a)throw TypeError(`"${getOptionName(a)}" must not be ${n}. It must be a writable stream, not readable.`)},getInvalidStdioOptionMessage=(r,n,a,s)=>{if("all"===r&&!a.all)return'The "all" option must be true to use "from: \'all\'".';let{optionName:l,optionValue:d}=getInvalidStdioOption(r,a);return`The "${l}: ${serializeOptionValue(d)}" option is incompatible with using "${getOptionName(s)}: ${serializeOptionValue(n)}".
Please set this option with "pipe" instead.`},getInvalidStdioOption=(r,{stdin:n,stdout:a,stderr:s,stdio:l})=>{let d=getUsedDescriptor(r);return 0===d&&void 0!==n?{optionName:"stdin",optionValue:n}:1===d&&void 0!==a?{optionName:"stdout",optionValue:a}:2===d&&void 0!==s?{optionName:"stderr",optionValue:s}:{optionName:`stdio[${d}]`,optionValue:l[d]}},getUsedDescriptor=r=>"all"===r?1:r,getOptionName=r=>r?"to":"from",serializeOptionValue=r=>"string"==typeof r?`'${r}'`:"number"==typeof r?`${r}`:"Stream",incrementMaxListeners=(r,n,a)=>{let s=r.getMaxListeners();0!==s&&s!==Number.POSITIVE_INFINITY&&(r.setMaxListeners(s+n),(0,ei.addAbortListener)(a,()=>{r.setMaxListeners(r.getMaxListeners()-n)}))},addReference=(r,n)=>{n&&addReferenceCount(r)},addReferenceCount=r=>{r.refCounted()},removeReference=(r,n)=>{n&&removeReferenceCount(r)},removeReferenceCount=r=>{r.unrefCounted()},undoAddedReferences=(r,n)=>{n&&(removeReferenceCount(r),removeReferenceCount(r))},redoAddedReferences=(r,n)=>{n&&(addReferenceCount(r),addReferenceCount(r))},onMessage=async({anyProcess:r,channel:n,isSubprocess:a,ipcEmitter:s},l)=>{if(handleStrictResponse(l)||handleAbort(l))return;el.has(r)||el.set(r,[]);let d=el.get(r);if(d.push(l),!(d.length>1))for(;d.length>0;){await waitForOutgoingMessages(r,s,l),await Y.scheduler.yield();let u=await handleStrictRequest({wrappedMessage:d[0],anyProcess:r,channel:n,isSubprocess:a,ipcEmitter:s});d.shift(),s.emit("message",u),s.emit("message:done")}},onDisconnect=async({anyProcess:r,channel:n,isSubprocess:a,ipcEmitter:s,boundOnMessage:l})=>{abortOnDisconnect();let d=el.get(r);for(;d?.length>0;)await (0,ei.once)(s,"message:done");r.removeListener("message",l),redoAddedReferences(n,a),s.connected=!1,s.emit("disconnect")},el=new WeakMap,getIpcEmitter=(r,n,a)=>{if(ec.has(r))return ec.get(r);let s=new ei.EventEmitter;return s.connected=!0,ec.set(r,s),forwardEvents({ipcEmitter:s,anyProcess:r,channel:n,isSubprocess:a}),s},ec=new WeakMap,forwardEvents=({ipcEmitter:r,anyProcess:n,channel:a,isSubprocess:s})=>{let l=onMessage.bind(void 0,{anyProcess:n,channel:a,isSubprocess:s,ipcEmitter:r});n.on("message",l),n.once("disconnect",onDisconnect.bind(void 0,{anyProcess:n,channel:a,isSubprocess:s,ipcEmitter:r,boundOnMessage:l})),undoAddedReferences(a,s)},isConnected=r=>{let n=ec.get(r);return void 0===n?null!==r.channel:n.connected},handleSendStrict=({anyProcess:r,channel:n,isSubprocess:a,message:s,strict:l})=>{if(!l)return s;let d=getIpcEmitter(r,n,a),u=hasMessageListeners(r,d);return{id:ed++,type:ep,message:s,hasListeners:u}},ed=0n,validateStrictDeadlock=(r,n)=>{if(n?.type===ep&&!n.hasListeners)for(let{id:n}of r)void 0!==n&&eu[n].resolve({isDeadlock:!0,hasListeners:!1})},handleStrictRequest=async({wrappedMessage:r,anyProcess:n,channel:a,isSubprocess:s,ipcEmitter:l})=>{if(r?.type!==ep||!n.connected)return r;let{id:d,message:u}=r,p={id:d,type:em,message:hasMessageListeners(n,l)};try{await sendMessage({anyProcess:n,channel:a,isSubprocess:s,ipc:!0},p)}catch(r){l.emit("strict:error",r)}return u},handleStrictResponse=r=>{if(r?.type!==em)return!1;let{id:n,message:a}=r;return eu[n]?.resolve({isDeadlock:!1,hasListeners:a}),!0},waitForStrictResponse=async(r,n,a)=>{if(r?.type!==ep)return;let s=createDeferred();eu[r.id]=s;let l=new AbortController;try{let{isDeadlock:r,hasListeners:d}=await Promise.race([s,throwOnDisconnect(n,a,l)]);r&&throwOnStrictDeadlockError(a),d||throwOnMissingStrict(a)}finally{l.abort(),delete eu[r.id]}},eu={},throwOnDisconnect=async(r,n,{signal:a})=>{incrementMaxListeners(r,1,a),await (0,ei.once)(r,"disconnect",{signal:a}),throwOnStrictDisconnect(n)},ep="execa:ipc:request",em="execa:ipc:response",startSendMessage=(r,n,a)=>{ef.has(r)||ef.set(r,new Set);let s=ef.get(r),l=createDeferred(),d=a?n.id:void 0,u={onMessageSent:l,id:d};return s.add(u),{outgoingMessages:s,outgoingMessage:u}},endSendMessage=({outgoingMessages:r,outgoingMessage:n})=>{r.delete(n),n.onMessageSent.resolve()},waitForOutgoingMessages=async(r,n,a)=>{for(;!hasMessageListeners(r,n)&&ef.get(r)?.size>0;){let n=[...ef.get(r)];validateStrictDeadlock(n,a),await Promise.all(n.map(({onMessageSent:r})=>r))}},ef=new WeakMap,hasMessageListeners=(r,n)=>n.listenerCount("message")>getMinListenerCount(r),getMinListenerCount=r=>es.has(r)&&!getFdSpecificValue(es.get(r).options.buffer,"ipc")?1:0,sendMessage=({anyProcess:r,channel:n,isSubprocess:a,ipc:s},l,{strict:d=!1}={})=>{let u="sendMessage";return validateIpcMethod({methodName:u,isSubprocess:a,ipc:s,isConnected:r.connected}),sendMessageAsync({anyProcess:r,channel:n,methodName:u,isSubprocess:a,message:l,strict:d})},sendMessageAsync=async({anyProcess:r,channel:n,methodName:a,isSubprocess:s,message:l,strict:d})=>{let u=handleSendStrict({anyProcess:r,channel:n,isSubprocess:s,message:l,strict:d}),p=startSendMessage(r,u,d);try{await sendOneMessage({anyProcess:r,methodName:a,isSubprocess:s,wrappedMessage:u,message:l})}catch(n){throw disconnect(r),n}finally{endSendMessage(p)}},sendOneMessage=async({anyProcess:r,methodName:n,isSubprocess:a,wrappedMessage:s,message:l})=>{let d=getSendMethod(r);try{await Promise.all([waitForStrictResponse(s,r,a),d(s)])}catch(r){throw handleEpipeError({error:r,methodName:n,isSubprocess:a}),handleSerializationError({error:r,methodName:n,isSubprocess:a,message:l}),r}},getSendMethod=r=>{if(eh.has(r))return eh.get(r);let n=(0,b.promisify)(r.send.bind(r));return eh.set(r,n),n},eh=new WeakMap,sendAbort=(r,n)=>{let a="cancelSignal";return validateConnection(a,!1,r.connected),sendOneMessage({anyProcess:r,methodName:a,isSubprocess:!1,wrappedMessage:{type:ey,message:n},message:n})},getCancelSignal=async({anyProcess:r,channel:n,isSubprocess:a,ipc:s})=>(await startIpc({anyProcess:r,channel:n,isSubprocess:a,ipc:s}),eb.signal),startIpc=async({anyProcess:r,channel:n,isSubprocess:a,ipc:s})=>{if(!eg){if(eg=!0,!s){throwOnMissingParent();return}if(null===n){abortOnDisconnect();return}getIpcEmitter(r,n,a),await Y.scheduler.yield()}},eg=!1,handleAbort=r=>r?.type===ey&&(eb.abort(r.message),!0),ey="execa:ipc:cancel",abortOnDisconnect=()=>{eb.abort(getAbortDisconnectError())},eb=new AbortController,validateGracefulCancel=({gracefulCancel:r,cancelSignal:n,ipc:a,serialization:s})=>{if(r){if(void 0===n)throw Error("The `cancelSignal` option must be defined when setting the `gracefulCancel` option.");if(!a)throw Error("The `ipc` option cannot be false when setting the `gracefulCancel` option.");if("json"===s)throw Error("The `serialization` option cannot be 'json' when setting the `gracefulCancel` option.")}},throwOnGracefulCancel=({subprocess:r,cancelSignal:n,gracefulCancel:a,forceKillAfterDelay:s,context:l,controller:d})=>a?[sendOnAbort({subprocess:r,cancelSignal:n,forceKillAfterDelay:s,context:l,controller:d})]:[],sendOnAbort=async({subprocess:r,cancelSignal:n,forceKillAfterDelay:a,context:s,controller:{signal:l}})=>{await onAbortedSignal(n,l);let d=getReason(n);throw await sendAbort(r,d),killOnTimeout({kill:r.kill,forceKillAfterDelay:a,context:s,controllerSignal:l}),s.terminationReason??="gracefulCancel",n.reason},getReason=({reason:r})=>{if(!(r instanceof DOMException))return r;let n=Error(r.message);return Object.defineProperty(n,"stack",{value:r.stack,enumerable:!1,configurable:!0,writable:!0}),n},validateTimeout=({timeout:r})=>{if(void 0!==r&&(!Number.isFinite(r)||r<0))throw TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${r}\` (${typeof r})`)},throwOnTimeout=(r,n,a,s)=>0===n||void 0===n?[]:[killAfterTimeout(r,n,a,s)],killAfterTimeout=async(r,n,a,{signal:s})=>{throw await (0,Y.setTimeout)(n,void 0,{signal:s}),a.terminationReason??="timeout",r.kill(),new DiscardedError},handleNodeOption=(r,n,{node:a=!1,nodePath:s=S.execPath,nodeOptions:l=S.execArgv.filter(r=>!r.startsWith("--inspect")),cwd:d,execPath:u,...p})=>{if(void 0!==u)throw TypeError('The "execPath" option has been removed. Please use the "nodePath" option instead.');let m=safeNormalizeFileUrl(s,'The "nodePath" option'),f=K.resolve(d,m),g={...p,nodePath:f,node:a,cwd:d};if(!a)return[r,n,g];if("node"===K.basename(r,".exe"))throw TypeError('When the "node" option is true, the first argument does not need to be "node".');return[f,[...l,r,...n],{ipc:!0,...g,shell:!1}]};var eS=a(3858);let validateIpcInputOption=({ipcInput:r,ipc:n,serialization:a})=>{if(void 0!==r){if(!n)throw Error("The `ipcInput` option cannot be set unless the `ipc` option is `true`.");ew[a](r)}},ew={advanced:r=>{try{(0,eS.serialize)(r)}catch(r){throw Error("The `ipcInput` option is not serializable with a structured clone.",{cause:r})}},json:r=>{try{JSON.stringify(r)}catch(r){throw Error("The `ipcInput` option is not serializable with JSON.",{cause:r})}}},sendIpcInput=async(r,n)=>{void 0!==n&&await r.sendMessage(n)},validateEncoding=({encoding:r})=>{if(eO.has(r))return;let n=getCorrectEncoding(r);if(void 0!==n)throw TypeError(`Invalid option \`encoding: ${serializeEncoding(r)}\`.
Please rename it to ${serializeEncoding(n)}.`);let a=[...eO].map(r=>serializeEncoding(r)).join(", ");throw TypeError(`Invalid option \`encoding: ${serializeEncoding(r)}\`.
Please rename it to one of: ${a}.`)},ev=new Set(["utf8","utf16le"]),eE=new Set(["buffer","hex","base64","base64url","latin1","ascii"]),eO=new Set([...ev,...eE]),getCorrectEncoding=r=>{if(null===r)return"buffer";if("string"!=typeof r)return;let n=r.toLowerCase();return n in eT?eT[n]:eO.has(n)?n:void 0},eT={"utf-8":"utf8","utf-16le":"utf16le","ucs-2":"utf16le",ucs2:"utf16le",binary:"latin1"},serializeEncoding=r=>"string"==typeof r?`"${r}"`:String(r);var ex=a(7561);let normalizeCwd=(r=getDefaultCwd())=>{let n=safeNormalizeFileUrl(r,'The "cwd" option');return K.resolve(n)},getDefaultCwd=()=>{try{return S.cwd()}catch(r){throw r.message=`The current directory does not exist.
${r.message}`,r}},fixCwdError=(r,n)=>{let a;if(n===getDefaultCwd())return r;try{a=(0,ex.statSync)(n)}catch(a){return`The "cwd" option is invalid: ${n}.
${a.message}
${r}`}return a.isDirectory()?r:`The "cwd" option is not a directory: ${n}.
${r}`},normalizeOptions=(r,n,a)=>{a.cwd=normalizeCwd(a.cwd);let[s,l,d]=handleNodeOption(r,n,a),{command:u,args:p,options:m}=q._parse(s,l,d),f=normalizeFdSpecificOptions(m),g=addDefaultOptions(f);return validateTimeout(g),validateEncoding(g),validateIpcInputOption(g),validateCancelSignal(g),validateGracefulCancel(g),g.shell=normalizeFileUrl(g.shell),g.env=getEnv(g),g.killSignal=normalizeKillSignal(g.killSignal),g.forceKillAfterDelay=normalizeForceKillAfterDelay(g.forceKillAfterDelay),g.lines=g.lines.map((r,n)=>r&&!eE.has(g.encoding)&&g.buffer[n]),"win32"===S.platform&&"cmd"===K.basename(u,".exe")&&p.unshift("/q"),{file:u,commandArguments:p,options:g}},addDefaultOptions=({extendEnv:r=!0,preferLocal:n=!1,cwd:a,localDir:s=a,encoding:l="utf8",reject:d=!0,cleanup:u=!0,all:p=!1,windowsHide:m=!0,killSignal:f="SIGTERM",forceKillAfterDelay:g=!0,gracefulCancel:y=!1,ipcInput:b,ipc:S=void 0!==b||y,serialization:w="advanced",...v})=>({...v,extendEnv:r,preferLocal:n,cwd:a,localDirectory:s,encoding:l,reject:d,cleanup:u,all:p,windowsHide:m,killSignal:f,forceKillAfterDelay:g,gracefulCancel:y,ipcInput:b,ipc:S,serialization:w}),getEnv=({env:r,extendEnv:n,preferLocal:a,node:s,localDirectory:l,nodePath:d})=>{let u=n?{...S.env,...r}:r;return a||s?npmRunPathEnv({env:u,cwd:l,execPath:d,preferLocal:a,addExecPath:s}):u},concatenateShell=(r,n,a)=>a.shell&&n.length>0?[[r,...n].join(" "),[],a]:[r,n,a];function strip_final_newline_stripFinalNewline(r){if("string"==typeof r)return stripFinalNewlineString(r);if(!(ArrayBuffer.isView(r)&&1===r.BYTES_PER_ELEMENT))throw Error("Input must be a string or a Uint8Array");return stripFinalNewlineBinary(r)}let stripFinalNewlineString=r=>r.at(-1)===eD?r.slice(0,r.at(-2)===eA?-2:-1):r,stripFinalNewlineBinary=r=>r.at(-1)===eI?r.subarray(0,r.at(-2)===eM?-2:-1):r,eD="\n",eI=eD.codePointAt(0),eA="\r",eM=eA.codePointAt(0);function isStream(r,{checkOpen:n=!0}={}){return null!==r&&"object"==typeof r&&(r.writable||r.readable||!n||void 0===r.writable&&void 0===r.readable)&&"function"==typeof r.pipe}function isWritableStream(r,{checkOpen:n=!0}={}){return isStream(r,{checkOpen:n})&&(r.writable||!n)&&"function"==typeof r.write&&"function"==typeof r.end&&"boolean"==typeof r.writable&&"boolean"==typeof r.writableObjectMode&&"function"==typeof r.destroy&&"boolean"==typeof r.destroyed}function isReadableStream(r,{checkOpen:n=!0}={}){return isStream(r,{checkOpen:n})&&(r.readable||!n)&&"function"==typeof r.read&&"boolean"==typeof r.readable&&"boolean"==typeof r.readableObjectMode&&"function"==typeof r.destroy&&"boolean"==typeof r.destroyed}function isDuplexStream(r,n){return isWritableStream(r,n)&&isReadableStream(r,n)}let eF=Object.getPrototypeOf(Object.getPrototypeOf(async function*(){}).prototype);let c=class c{#e;#t;#r;#n;constructor(r,n){this.#r=!1,this.#n=void 0,this.#e=r,this.#t=n}next(){let e=()=>this.#i();return this.#n=this.#n?this.#n.then(e,e):e(),this.#n}return(r){let t=()=>this.#a(r);return this.#n?this.#n.then(t,t):t()}async #i(){let r;if(this.#r)return{done:!0,value:void 0};try{r=await this.#e.read()}catch(r){throw this.#n=void 0,this.#r=!0,this.#e.releaseLock(),r}return r.done&&(this.#n=void 0,this.#r=!0,this.#e.releaseLock()),r}async #a(r){if(this.#r)return{done:!0,value:r};if(this.#r=!0,!this.#t){let n=this.#e.cancel(r);return this.#e.releaseLock(),await n,{done:!0,value:r}}return this.#e.releaseLock(),{done:!0,value:r}}};let eR=Symbol();function i(){return this[eR].next()}function o(r){return this[eR].return(r)}Object.defineProperty(i,"name",{value:"next"}),Object.defineProperty(o,"name",{value:"return"});let eC=Object.create(eF,{next:{enumerable:!0,configurable:!0,writable:!0,value:i},return:{enumerable:!0,configurable:!0,writable:!0,value:o}});function h({preventCancel:r=!1}={}){let n=this.getReader(),a=new c(n,r),s=Object.create(eC);return s[eR]=a,s}let getAsyncIterable=r=>{if(isReadableStream(r,{checkOpen:!1})&&void 0!==eN.on)return getStreamIterable(r);if("function"==typeof r?.[Symbol.asyncIterator])return r;if("[object ReadableStream]"===eP.call(r))return h.call(r);throw TypeError("The first argument must be a Readable, a ReadableStream, or an async iterable.")},{toString:eP}=Object.prototype,getStreamIterable=async function*(r){let n=new AbortController,a={};handleStreamEnd(r,n,a);try{for await(let[a]of eN.on(r,"data",{signal:n.signal}))yield a}catch(r){if(void 0!==a.error)throw a.error;if(!n.signal.aborted)throw r}finally{r.destroy()}},handleStreamEnd=async(r,n,a)=>{try{await eN.finished(r,{cleanup:!0,readable:!0,writable:!1,error:!1})}catch(r){a.error=r}finally{n.abort()}},eN={},getStreamContents=async(r,{init:n,convertChunk:a,getSize:s,truncateChunk:l,addChunk:d,getFinalChunk:u,finalize:p},{maxBuffer:m=Number.POSITIVE_INFINITY}={})=>{let f=getAsyncIterable(r),g=n();g.length=0;try{for await(let r of f){let n=getChunkType(r),u=a[n](r,g);appendChunk({convertedChunk:u,state:g,getSize:s,truncateChunk:l,addChunk:d,maxBuffer:m})}return appendFinalChunk({state:g,convertChunk:a,getSize:s,truncateChunk:l,addChunk:d,getFinalChunk:u,maxBuffer:m}),p(g)}catch(n){let r="object"==typeof n&&null!==n?n:Error(n);throw r.bufferedData=p(g),r}},appendFinalChunk=({state:r,getSize:n,truncateChunk:a,addChunk:s,getFinalChunk:l,maxBuffer:d})=>{let u=l(r);void 0!==u&&appendChunk({convertedChunk:u,state:r,getSize:n,truncateChunk:a,addChunk:s,maxBuffer:d})},appendChunk=({convertedChunk:r,state:n,getSize:a,truncateChunk:s,addChunk:l,maxBuffer:d})=>{let u=a(r),p=n.length+u;if(p<=d){addNewChunk(r,n,l,p);return}let m=s(r,d-n.length);throw void 0!==m&&addNewChunk(m,n,l,d),new MaxBufferError},addNewChunk=(r,n,a,s)=>{n.contents=a(r,n,s),n.length=s},getChunkType=r=>{let n=typeof r;if("string"===n)return"string";if("object"!==n||null===r)return"others";if(globalThis.Buffer?.isBuffer(r))return"buffer";let a=e$.call(r);return"[object ArrayBuffer]"===a?"arrayBuffer":"[object DataView]"===a?"dataView":Number.isInteger(r.byteLength)&&Number.isInteger(r.byteOffset)&&"[object ArrayBuffer]"===e$.call(r.buffer)?"typedArray":"others"},{toString:e$}=Object.prototype;let MaxBufferError=class MaxBufferError extends Error{constructor(){super("maxBuffer exceeded"),this.name="MaxBufferError"}};let handleMaxBuffer=({error:r,stream:n,readableObjectMode:a,lines:s,encoding:l,fdNumber:d})=>{if(!(r instanceof MaxBufferError))throw r;if("all"===d)return r;let u=getMaxBufferUnit(a,s,l);throw r.maxBufferInfo={fdNumber:d,unit:u},n.destroy(),r},getMaxBufferUnit=(r,n,a)=>r?"objects":n?"lines":"buffer"===a?"bytes":"characters",checkIpcMaxBuffer=(r,n,a)=>{if(n.length!==a)return;let s=new MaxBufferError;throw s.maxBufferInfo={fdNumber:"ipc"},s},getMaxBufferMessage=(r,n)=>{let{streamName:a,threshold:s,unit:l}=getMaxBufferInfo(r,n);return`Command's ${a} was larger than ${s} ${l}`},getMaxBufferInfo=(r,n)=>{if(r?.maxBufferInfo===void 0)return{streamName:"output",threshold:n[1],unit:"bytes"};let{maxBufferInfo:{fdNumber:a,unit:s}}=r;delete r.maxBufferInfo;let l=getFdSpecificValue(n,a);return"ipc"===a?{streamName:"IPC output",threshold:l,unit:"messages"}:{streamName:getStreamName(a),threshold:l,unit:s}},isMaxBufferSync=(r,n,a)=>r?.code==="ENOBUFS"&&null!==n&&n.some(r=>null!==r&&r.length>getMaxBufferSync(a)),truncateMaxBufferSync=(r,n,a)=>{if(!n)return r;let s=getMaxBufferSync(a);return r.length>s?r.slice(0,s):r},getMaxBufferSync=([,r])=>r,createMessages=({stdio:r,all:n,ipcOutput:a,originalError:s,signal:l,signalDescription:d,exitCode:u,escapedCommand:p,timedOut:m,isCanceled:f,isGracefullyCanceled:g,isMaxBuffer:y,isForcefullyTerminated:b,forceKillAfterDelay:S,killSignal:w,maxBuffer:v,timeout:E,cwd:O})=>{let T=s?.code,x=getErrorPrefix({originalError:s,timedOut:m,timeout:E,isMaxBuffer:y,maxBuffer:v,errorCode:T,signal:l,signalDescription:d,exitCode:u,isCanceled:f,isGracefullyCanceled:g,isForcefullyTerminated:b,forceKillAfterDelay:S,killSignal:w}),D=getOriginalMessage(s,O),I=void 0===D?"":`
${D}`,A=`${x}: ${p}${I}`,M=void 0===n?[r[2],r[1]]:[n],F=[A,...M,...r.slice(3),a.map(r=>serializeIpcMessage(r)).join("\n")].map(r=>escapeLines(strip_final_newline_stripFinalNewline(serializeMessagePart(r)))).filter(Boolean).join("\n\n");return{originalMessage:D,shortMessage:A,message:F}},getErrorPrefix=({originalError:r,timedOut:n,timeout:a,isMaxBuffer:s,maxBuffer:l,errorCode:d,signal:u,signalDescription:p,exitCode:m,isCanceled:f,isGracefullyCanceled:g,isForcefullyTerminated:y,forceKillAfterDelay:b,killSignal:S})=>{let w=getForcefulSuffix(y,b);return n?`Command timed out after ${a} milliseconds${w}`:g?void 0===u?`Command was gracefully canceled with exit code ${m}`:y?`Command was gracefully canceled${w}`:`Command was gracefully canceled with ${u} (${p})`:f?`Command was canceled${w}`:s?`${getMaxBufferMessage(r,l)}${w}`:void 0!==d?`Command failed with ${d}${w}`:y?`Command was killed with ${S} (${getSignalDescription(S)})${w}`:void 0!==u?`Command was killed with ${u} (${p})`:void 0!==m?`Command failed with exit code ${m}`:"Command failed"},getForcefulSuffix=(r,n)=>r?` and was forcefully terminated after ${n} milliseconds`:"",getOriginalMessage=(r,n)=>{if(r instanceof DiscardedError)return;let a=isExecaError(r)?r.originalMessage:String(r?.message??r),s=escapeLines(fixCwdError(a,n));return""===s?void 0:s},serializeIpcMessage=r=>"string"==typeof r?r:(0,b.inspect)(r),serializeMessagePart=r=>Array.isArray(r)?r.map(r=>strip_final_newline_stripFinalNewline(serializeMessageItem(r))).filter(Boolean).join("\n"):serializeMessageItem(r),serializeMessageItem=r=>"string"==typeof r?r:isUint8Array(r)?uint8ArrayToString(r):"",makeSuccessResult=({command:r,escapedCommand:n,stdio:a,all:s,ipcOutput:l,options:{cwd:d},startTime:u})=>omitUndefinedProperties({command:r,escapedCommand:n,cwd:d,durationMs:getDurationMs(u),failed:!1,timedOut:!1,isCanceled:!1,isGracefullyCanceled:!1,isTerminated:!1,isMaxBuffer:!1,isForcefullyTerminated:!1,exitCode:0,stdout:a[1],stderr:a[2],all:s,stdio:a,ipcOutput:l,pipedFrom:[]}),makeEarlyError=({error:r,command:n,escapedCommand:a,fileDescriptors:s,options:l,startTime:d,isSync:u})=>makeError({error:r,command:n,escapedCommand:a,startTime:d,timedOut:!1,isCanceled:!1,isGracefullyCanceled:!1,isMaxBuffer:!1,isForcefullyTerminated:!1,stdio:Array.from({length:s.length}),ipcOutput:[],options:l,isSync:u}),makeError=({error:r,command:n,escapedCommand:a,startTime:s,timedOut:l,isCanceled:d,isGracefullyCanceled:u,isMaxBuffer:p,isForcefullyTerminated:m,exitCode:f,signal:g,stdio:y,all:b,ipcOutput:S,options:{timeoutDuration:w,timeout:v=w,forceKillAfterDelay:E,killSignal:O,cwd:T,maxBuffer:x},isSync:D})=>{let{exitCode:I,signal:A,signalDescription:M}=normalizeExitPayload(f,g),{originalMessage:F,shortMessage:R,message:C}=createMessages({stdio:y,all:b,ipcOutput:S,originalError:r,signal:A,signalDescription:M,exitCode:I,escapedCommand:a,timedOut:l,isCanceled:d,isGracefullyCanceled:u,isMaxBuffer:p,isForcefullyTerminated:m,forceKillAfterDelay:E,killSignal:O,maxBuffer:x,timeout:v,cwd:T}),P=getFinalError(r,C,D);return Object.assign(P,getErrorProperties({error:P,command:n,escapedCommand:a,startTime:s,timedOut:l,isCanceled:d,isGracefullyCanceled:u,isMaxBuffer:p,isForcefullyTerminated:m,exitCode:I,signal:A,signalDescription:M,stdio:y,all:b,ipcOutput:S,cwd:T,originalMessage:F,shortMessage:R})),P},getErrorProperties=({error:r,command:n,escapedCommand:a,startTime:s,timedOut:l,isCanceled:d,isGracefullyCanceled:u,isMaxBuffer:p,isForcefullyTerminated:m,exitCode:f,signal:g,signalDescription:y,stdio:b,all:S,ipcOutput:w,cwd:v,originalMessage:E,shortMessage:O})=>omitUndefinedProperties({shortMessage:O,originalMessage:E,command:n,escapedCommand:a,cwd:v,durationMs:getDurationMs(s),failed:!0,timedOut:l,isCanceled:d,isGracefullyCanceled:u,isTerminated:void 0!==g,isMaxBuffer:p,isForcefullyTerminated:m,exitCode:f,signal:g,signalDescription:y,code:r.cause?.code,stdout:b[1],stderr:b[2],all:S,stdio:b,ipcOutput:w,pipedFrom:[]}),omitUndefinedProperties=r=>Object.fromEntries(Object.entries(r).filter(([,r])=>void 0!==r)),normalizeExitPayload=(r,n)=>{let a=null===n?void 0:n,s=void 0===a?void 0:getSignalDescription(n);return{exitCode:null===r?void 0:r,signal:a,signalDescription:s}},toZeroIfInfinity=r=>Number.isFinite(r)?r:0;function parseNumber(r){return{days:Math.trunc(r/864e5),hours:Math.trunc(r/36e5%24),minutes:Math.trunc(r/6e4%60),seconds:Math.trunc(r/1e3%60),milliseconds:Math.trunc(r%1e3),microseconds:Math.trunc(toZeroIfInfinity(1e3*r)%1e3),nanoseconds:Math.trunc(toZeroIfInfinity(1e6*r)%1e3)}}function parseBigint(r){return{days:r/86400000n,hours:r/3600000n%24n,minutes:r/60000n%60n,seconds:r/1000n%60n,milliseconds:r%1000n,microseconds:0n,nanoseconds:0n}}function parseMilliseconds(r){switch(typeof r){case"number":if(Number.isFinite(r))return parseNumber(r);break;case"bigint":return parseBigint(r)}throw TypeError("Expected a finite number or bigint")}let isZero=r=>0===r||0n===r,pluralize=(r,n)=>1===n||1n===n?r:`${r}s`,eB=24n*60n*60n*1000n;function prettyMilliseconds(r,n){let a="bigint"==typeof r;if(!a&&!Number.isFinite(r))throw TypeError("Expected a finite number or bigint");n={...n};let s=r<0?"-":"";r=r<0?-r:r,n.colonNotation&&(n.compact=!1,n.formatSubMilliseconds=!1,n.separateMilliseconds=!1,n.verbose=!1),n.compact&&(n.unitCount=1,n.secondsDecimalDigits=0,n.millisecondsDecimalDigits=0);let l=[],add=(r,a,s,d)=>{if(!((0===l.length||!n.colonNotation)&&isZero(r))||n.colonNotation&&"m"===s){if(d??=String(r),n.colonNotation){let r=d.includes(".")?d.split(".")[0].length:d.length,n=l.length>0?2:1;d="0".repeat(Math.max(0,n-r))+d}else d+=n.verbose?" "+pluralize(a,r):s;l.push(d)}},d=parseMilliseconds(r),u=BigInt(d.days);if(n.hideYearAndDays?add(24n*BigInt(u)+BigInt(d.hours),"hour","h"):(n.hideYear?add(u,"day","d"):(add(u/365n,"year","y"),add(u%365n,"day","d")),add(Number(d.hours),"hour","h")),add(Number(d.minutes),"minute","m"),!n.hideSeconds){if(n.separateMilliseconds||n.formatSubMilliseconds||!n.colonNotation&&r<1e3&&!n.subSecondsAsDecimals){let r=Number(d.seconds),a=Number(d.milliseconds),s=Number(d.microseconds),l=Number(d.nanoseconds);if(add(r,"second","s"),n.formatSubMilliseconds)add(a,"millisecond","ms"),add(s,"microsecond","\xb5s"),add(l,"nanosecond","ns");else{let r=a+s/1e3+l/1e6,d="number"==typeof n.millisecondsDecimalDigits?n.millisecondsDecimalDigits:0,u=d?r.toFixed(d):r>=1?Math.round(r):Math.ceil(r);add(Number.parseFloat(u),"millisecond","ms",u)}}else{let s=(a?Number(r%eB):r)/1e3%60,l="number"==typeof n.secondsDecimalDigits?n.secondsDecimalDigits:1,d=((r,n)=>{let a=Math.floor(r*10**n+1e-7),s=Math.round(a)/10**n;return s.toFixed(n)})(s,l),u=n.keepDecimalsOnWholeSeconds?d:d.replace(/\.0+$/,"");add(Number.parseFloat(u),"second","s",u)}}if(0===l.length)return s+"0"+(n.verbose?" milliseconds":"ms");let p=n.colonNotation?":":" ";return"number"==typeof n.unitCount&&(l=l.slice(0,Math.max(n.unitCount,1))),s+l.join(p)}let logError=(r,n)=>{r.failed&&verboseLog({type:"error",verboseMessage:r.shortMessage,verboseInfo:n,result:r})},logResult=(r,n)=>{isVerbose(n)&&(logError(r,n),logDuration(r,n))},logDuration=(r,n)=>{let a=`(done in ${prettyMilliseconds(r.durationMs)})`;verboseLog({type:"duration",verboseMessage:a,verboseInfo:n,result:r})},handleResult=(r,n,{reject:a})=>{if(logResult(r,n),r.failed&&a)throw r;return r},getStdioItemType=(r,n)=>isAsyncGenerator(r)?"asyncGenerator":isSyncGenerator(r)?"generator":isUrl(r)?"fileUrl":isFilePathObject(r)?"filePath":isWebStream(r)?"webStream":isStream(r,{checkOpen:!1})?"native":isUint8Array(r)?"uint8Array":isAsyncIterableObject(r)?"asyncIterable":isIterableObject(r)?"iterable":type_isTransformStream(r)?getTransformStreamType({transform:r},n):isTransformOptions(r)?getTransformObjectType(r,n):"native",getTransformObjectType=(r,n)=>isDuplexStream(r.transform,{checkOpen:!1})?getDuplexType(r,n):type_isTransformStream(r.transform)?getTransformStreamType(r,n):getGeneratorObjectType(r,n),getDuplexType=(r,n)=>(validateNonGeneratorType(r,n,"Duplex stream"),"duplex"),getTransformStreamType=(r,n)=>(validateNonGeneratorType(r,n,"web TransformStream"),"webTransform"),validateNonGeneratorType=({final:r,binary:n,objectMode:a},s,l)=>{checkUndefinedOption(r,`${s}.final`,l),checkUndefinedOption(n,`${s}.binary`,l),checkBooleanOption(a,`${s}.objectMode`)},checkUndefinedOption=(r,n,a)=>{if(void 0!==r)throw TypeError(`The \`${n}\` option can only be defined when using a generator, not a ${a}.`)},getGeneratorObjectType=({transform:r,final:n,binary:a,objectMode:s},l)=>{if(void 0!==r&&!isGenerator(r))throw TypeError(`The \`${l}.transform\` option must be a generator, a Duplex stream or a web TransformStream.`);if(isDuplexStream(n,{checkOpen:!1}))throw TypeError(`The \`${l}.final\` option must not be a Duplex stream.`);if(type_isTransformStream(n))throw TypeError(`The \`${l}.final\` option must not be a web TransformStream.`);if(void 0!==n&&!isGenerator(n))throw TypeError(`The \`${l}.final\` option must be a generator.`);return checkBooleanOption(a,`${l}.binary`),checkBooleanOption(s,`${l}.objectMode`),isAsyncGenerator(r)||isAsyncGenerator(n)?"asyncGenerator":"generator"},checkBooleanOption=(r,n)=>{if(void 0!==r&&"boolean"!=typeof r)throw TypeError(`The \`${n}\` option must use a boolean.`)},isGenerator=r=>isAsyncGenerator(r)||isSyncGenerator(r),isAsyncGenerator=r=>"[object AsyncGeneratorFunction]"===Object.prototype.toString.call(r),isSyncGenerator=r=>"[object GeneratorFunction]"===Object.prototype.toString.call(r),isTransformOptions=r=>isPlainObject(r)&&(void 0!==r.transform||void 0!==r.final),isUrl=r=>"[object URL]"===Object.prototype.toString.call(r),isRegularUrl=r=>isUrl(r)&&"file:"!==r.protocol,isFilePathObject=r=>isPlainObject(r)&&Object.keys(r).length>0&&Object.keys(r).every(r=>eL.has(r))&&isFilePathString(r.file),eL=new Set(["file","append"]),isFilePathString=r=>"string"==typeof r,isUnknownStdioString=(r,n)=>"native"===r&&"string"==typeof n&&!eU.has(n),eU=new Set(["ipc","ignore","inherit","overlapped","pipe"]),type_isReadableStream=r=>"[object ReadableStream]"===Object.prototype.toString.call(r),type_isWritableStream=r=>"[object WritableStream]"===Object.prototype.toString.call(r),isWebStream=r=>type_isReadableStream(r)||type_isWritableStream(r),type_isTransformStream=r=>type_isReadableStream(r?.readable)&&type_isWritableStream(r?.writable),isAsyncIterableObject=r=>isObject(r)&&"function"==typeof r[Symbol.asyncIterator],isIterableObject=r=>isObject(r)&&"function"==typeof r[Symbol.iterator],isObject=r=>"object"==typeof r&&null!==r,ek=new Set(["generator","asyncGenerator","duplex","webTransform"]),ej=new Set(["fileUrl","filePath","fileNumber"]),ez=new Set(["fileUrl","filePath"]),eG=new Set([...ez,"webStream","nodeStream"]),eV=new Set(["webTransform","duplex"]),e_={generator:"a generator",asyncGenerator:"an async generator",fileUrl:"a file URL",filePath:"a file path string",fileNumber:"a file descriptor number",webStream:"a web stream",nodeStream:"a Node.js stream",webTransform:"a web TransformStream",duplex:"a Duplex stream",native:"any value",iterable:"an iterable",asyncIterable:"an async iterable",string:"a string",uint8Array:"a Uint8Array"},getTransformObjectModes=(r,n,a,s)=>"output"===s?getOutputObjectModes(r,n,a):getInputObjectModes(r,n,a),getOutputObjectModes=(r,n,a)=>{let s=0!==n&&a[n-1].value.readableObjectMode;return{writableObjectMode:s,readableObjectMode:r??s}},getInputObjectModes=(r,n,a)=>{let s=0===n?!0===r:a[n-1].value.readableObjectMode,l=n!==a.length-1&&(r??s);return{writableObjectMode:s,readableObjectMode:l}},getFdObjectMode=(r,n)=>{let a=r.findLast(({type:r})=>ek.has(r));return void 0!==a&&("input"===n?a.value.writableObjectMode:a.value.readableObjectMode)},normalizeTransforms=(r,n,a,s)=>[...r.filter(({type:r})=>!ek.has(r)),...getTransforms(r,n,a,s)],getTransforms=(r,n,a,{encoding:s})=>{let l=r.filter(({type:r})=>ek.has(r)),d=Array.from({length:l.length});for(let[r,u]of Object.entries(l))d[r]=normalizeTransform({stdioItem:u,index:Number(r),newTransforms:d,optionName:n,direction:a,encoding:s});return sortTransforms(d,a)},normalizeTransform=({stdioItem:r,stdioItem:{type:n},index:a,newTransforms:s,optionName:l,direction:d,encoding:u})=>"duplex"===n?normalizeDuplex({stdioItem:r,optionName:l}):"webTransform"===n?normalizeTransformStream({stdioItem:r,index:a,newTransforms:s,direction:d}):normalizeGenerator({stdioItem:r,index:a,newTransforms:s,direction:d,encoding:u}),normalizeDuplex=({stdioItem:r,stdioItem:{value:{transform:n,transform:{writableObjectMode:a,readableObjectMode:s},objectMode:l=s}},optionName:d})=>{if(l&&!s)throw TypeError(`The \`${d}.objectMode\` option can only be \`true\` if \`new Duplex({objectMode: true})\` is used.`);if(!l&&s)throw TypeError(`The \`${d}.objectMode\` option cannot be \`false\` if \`new Duplex({objectMode: true})\` is used.`);return{...r,value:{transform:n,writableObjectMode:a,readableObjectMode:s}}},normalizeTransformStream=({stdioItem:r,stdioItem:{value:n},index:a,newTransforms:s,direction:l})=>{let{transform:d,objectMode:u}=isPlainObject(n)?n:{transform:n},{writableObjectMode:p,readableObjectMode:m}=getTransformObjectModes(u,a,s,l);return{...r,value:{transform:d,writableObjectMode:p,readableObjectMode:m}}},normalizeGenerator=({stdioItem:r,stdioItem:{value:n},index:a,newTransforms:s,direction:l,encoding:d})=>{let{transform:u,final:p,binary:m=!1,preserveNewlines:f=!1,objectMode:g}=isPlainObject(n)?n:{transform:n},y=m||eE.has(d),{writableObjectMode:b,readableObjectMode:S}=getTransformObjectModes(g,a,s,l);return{...r,value:{transform:u,final:p,binary:y,preserveNewlines:f,writableObjectMode:b,readableObjectMode:S}}},sortTransforms=(r,n)=>"input"===n?r.reverse():r,getStreamDirection=(r,n,a)=>{let s=r.map(r=>getStdioItemDirection(r,n));if(s.includes("input")&&s.includes("output"))throw TypeError(`The \`${a}\` option must not be an array of both readable and writable values.`);return s.find(Boolean)??eK},getStdioItemDirection=({type:r,value:n},a)=>eW[a]??eH[r](n),eW=["input","output","output"],anyDirection=()=>void 0,alwaysInput=()=>"input",eH={generator:anyDirection,asyncGenerator:anyDirection,fileUrl:anyDirection,filePath:anyDirection,iterable:alwaysInput,asyncIterable:alwaysInput,uint8Array:alwaysInput,webStream:r=>type_isWritableStream(r)?"output":"input",nodeStream:r=>isReadableStream(r,{checkOpen:!1})?isWritableStream(r,{checkOpen:!1})?void 0:"input":"output",webTransform:anyDirection,duplex:anyDirection,native(r){let n=getStandardStreamDirection(r);return void 0!==n?n:isStream(r,{checkOpen:!1})?eH.nodeStream(r):void 0}},getStandardStreamDirection=r=>[0,S.stdin].includes(r)?"input":[1,2,S.stdout,S.stderr].includes(r)?"output":void 0,eK="output",normalizeIpcStdioArray=(r,n)=>n&&!r.includes("ipc")?[...r,"ipc"]:r,normalizeStdioOption=({stdio:r,ipc:n,buffer:a,...s},l,d)=>{let u=getStdioArray(r,s).map((r,n)=>stdio_option_addDefaultValue(r,n));return d?normalizeStdioSync(u,a,l):normalizeIpcStdioArray(u,n)},getStdioArray=(r,n)=>{if(void 0===r)return v.map(r=>n[r]);if(hasAlias(n))throw Error(`It's not possible to provide \`stdio\` in combination with one of ${v.map(r=>`\`${r}\``).join(", ")}`);if("string"==typeof r)return[r,r,r];if(!Array.isArray(r))throw TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof r}\``);let a=Math.max(r.length,v.length);return Array.from({length:a},(n,a)=>r[a])},hasAlias=r=>v.some(n=>void 0!==r[n]),stdio_option_addDefaultValue=(r,n)=>Array.isArray(r)?r.map(r=>stdio_option_addDefaultValue(r,n)):null==r?n>=v.length?"ignore":"pipe":r,normalizeStdioSync=(r,n,a)=>r.map((r,s)=>!n[s]&&0!==s&&!isFullVerbose(a,s)&&isOutputPipeOnly(r)?"ignore":r),isOutputPipeOnly=r=>"pipe"===r||Array.isArray(r)&&r.every(r=>"pipe"===r),handleNativeStream=({stdioItem:r,stdioItem:{type:n},isStdioArray:a,fdNumber:s,direction:l,isSync:d})=>a&&"native"===n?d?handleNativeStreamSync({stdioItem:r,fdNumber:s,direction:l}):handleNativeStreamAsync({stdioItem:r,fdNumber:s}):r,handleNativeStreamSync=({stdioItem:r,stdioItem:{value:n,optionName:a},fdNumber:s,direction:l})=>{let d=getTargetFd({value:n,optionName:a,fdNumber:s,direction:l});if(void 0!==d)return d;if(isStream(n,{checkOpen:!1}))throw TypeError(`The \`${a}: Stream\` option cannot both be an array and include a stream with synchronous methods.`);return r},getTargetFd=({value:r,optionName:n,fdNumber:a,direction:s})=>{let l=getTargetFdNumber(r,a);if(void 0!==l){if("output"===s)return{type:"fileNumber",value:l,optionName:n};if(L.isatty(l))throw TypeError(`The \`${n}: ${serializeOptionValue(r)}\` option is invalid: it cannot be a TTY with synchronous methods.`);return{type:"uint8Array",value:bufferToUint8Array((0,ex.readFileSync)(l)),optionName:n}}},getTargetFdNumber=(r,n)=>{if("inherit"===r)return n;if("number"==typeof r)return r;let a=w.indexOf(r);if(-1!==a)return a},handleNativeStreamAsync=({stdioItem:r,stdioItem:{value:n,optionName:a},fdNumber:s})=>"inherit"===n?{type:"nodeStream",value:getStandardStream(s,n,a),optionName:a}:"number"==typeof n?{type:"nodeStream",value:getStandardStream(n,n,a),optionName:a}:isStream(n,{checkOpen:!1})?{type:"nodeStream",value:n,optionName:a}:r,getStandardStream=(r,n,a)=>{let s=w[r];if(void 0===s)throw TypeError(`The \`${a}: ${n}\` option is invalid: no such standard stream.`);return s},handleInputOptions=({input:r,inputFile:n},a)=>0===a?[...handleInputOption(r),...handleInputFileOption(n)]:[],handleInputOption=r=>void 0===r?[]:[{type:getInputType(r),value:r,optionName:"input"}],getInputType=r=>{if(isReadableStream(r,{checkOpen:!1}))return"nodeStream";if("string"==typeof r)return"string";if(isUint8Array(r))return"uint8Array";throw Error("The `input` option must be a string, a Uint8Array or a Node.js Readable stream.")},handleInputFileOption=r=>void 0===r?[]:[{...getInputFileType(r),optionName:"inputFile"}],getInputFileType=r=>{if(isUrl(r))return{type:"fileUrl",value:r};if(isFilePathString(r))return{type:"filePath",value:{file:r}};throw Error("The `inputFile` option must be a file path string or a file URL.")},filterDuplicates=r=>r.filter((n,a)=>r.every((r,s)=>n.value!==r.value||a>=s||"generator"===n.type||"asyncGenerator"===n.type)),getDuplicateStream=({stdioItem:{type:r,value:n,optionName:a},direction:s,fileDescriptors:l,isSync:d})=>{let u=getOtherStdioItems(l,r);if(0!==u.length){if(d){validateDuplicateStreamSync({otherStdioItems:u,type:r,value:n,optionName:a,direction:s});return}if(eG.has(r))return getDuplicateStreamInstance({otherStdioItems:u,type:r,value:n,optionName:a,direction:s});eV.has(r)&&validateDuplicateTransform({otherStdioItems:u,type:r,value:n,optionName:a})}},getOtherStdioItems=(r,n)=>r.flatMap(({direction:r,stdioItems:a})=>a.filter(r=>r.type===n).map(n=>({...n,direction:r}))),validateDuplicateStreamSync=({otherStdioItems:r,type:n,value:a,optionName:s,direction:l})=>{ez.has(n)&&getDuplicateStreamInstance({otherStdioItems:r,type:n,value:a,optionName:s,direction:l})},getDuplicateStreamInstance=({otherStdioItems:r,type:n,value:a,optionName:s,direction:l})=>{let d=r.filter(r=>hasSameValue(r,a));if(0===d.length)return;let u=d.find(r=>r.direction!==l);return throwOnDuplicateStream(u,s,n),"output"===l?d[0].stream:void 0},hasSameValue=({type:r,value:n},a)=>"filePath"===r?n.file===a.file:"fileUrl"===r?n.href===a.href:n===a,validateDuplicateTransform=({otherStdioItems:r,type:n,value:a,optionName:s})=>{let l=r.find(({value:{transform:r}})=>r===a.transform);throwOnDuplicateStream(l,s,n)},throwOnDuplicateStream=(r,n,a)=>{if(void 0!==r)throw TypeError(`The \`${r.optionName}\` and \`${n}\` options must not target ${e_[a]} that is the same.`)},handleStdio=(r,n,a,s)=>{let l=normalizeStdioOption(n,a,s),d=l.map((r,a)=>getFileDescriptor({stdioOption:r,fdNumber:a,options:n,isSync:s})),u=getFinalFileDescriptors({initialFileDescriptors:d,addProperties:r,options:n,isSync:s});return n.stdio=u.map(({stdioItems:r})=>forwardStdio(r)),u},getFileDescriptor=({stdioOption:r,fdNumber:n,options:a,isSync:s})=>{let l=getStreamName(n),{stdioItems:d,isStdioArray:u}=initializeStdioItems({stdioOption:r,fdNumber:n,options:a,optionName:l}),p=getStreamDirection(d,n,l),m=d.map(r=>handleNativeStream({stdioItem:r,isStdioArray:u,fdNumber:n,direction:p,isSync:s})),f=normalizeTransforms(m,l,p,a),g=getFdObjectMode(f,p);return validateFileObjectMode(f,g),{direction:p,objectMode:g,stdioItems:f}},initializeStdioItems=({stdioOption:r,fdNumber:n,options:a,optionName:s})=>{let l=Array.isArray(r)?r:[r],d=[...l.map(r=>initializeStdioItem(r,s)),...handleInputOptions(a,n)],u=filterDuplicates(d),p=u.length>1;return validateStdioArray(u,p,s),validateStreams(u),{stdioItems:u,isStdioArray:p}},initializeStdioItem=(r,n)=>({type:getStdioItemType(r,n),value:r,optionName:n}),validateStdioArray=(r,n,a)=>{if(0===r.length)throw TypeError(`The \`${a}\` option must not be an empty array.`);if(n){for(let{value:n,optionName:a}of r)if(eq.has(n))throw Error(`The \`${a}\` option must not include \`${n}\`.`)}},eq=new Set(["ignore","ipc"]),validateStreams=r=>{for(let n of r)validateFileStdio(n)},validateFileStdio=({type:r,value:n,optionName:a})=>{if(isRegularUrl(n))throw TypeError(`The \`${a}: URL\` option must use the \`file:\` scheme.
For example, you can use the \`pathToFileURL()\` method of the \`url\` core module.`);if(isUnknownStdioString(r,n))throw TypeError(`The \`${a}: { file: '...' }\` option must be used instead of \`${a}: '...'\`.`)},validateFileObjectMode=(r,n)=>{if(!n)return;let a=r.find(({type:r})=>ej.has(r));if(void 0!==a)throw TypeError(`The \`${a.optionName}\` option cannot use both files and transforms in objectMode.`)},getFinalFileDescriptors=({initialFileDescriptors:r,addProperties:n,options:a,isSync:s})=>{let l=[];try{for(let d of r)l.push(getFinalFileDescriptor({fileDescriptor:d,fileDescriptors:l,addProperties:n,options:a,isSync:s}));return l}catch(r){throw cleanupCustomStreams(l),r}},getFinalFileDescriptor=({fileDescriptor:{direction:r,objectMode:n,stdioItems:a},fileDescriptors:s,addProperties:l,options:d,isSync:u})=>{let p=a.map(n=>addStreamProperties({stdioItem:n,addProperties:l,direction:r,options:d,fileDescriptors:s,isSync:u}));return{direction:r,objectMode:n,stdioItems:p}},addStreamProperties=({stdioItem:r,addProperties:n,direction:a,options:s,fileDescriptors:l,isSync:d})=>{let u=getDuplicateStream({stdioItem:r,direction:a,fileDescriptors:l,isSync:d});return void 0!==u?{...r,stream:u}:{...r,...n[a][r.type](r,s)}},cleanupCustomStreams=r=>{for(let{stdioItems:n}of r)for(let{stream:r}of n)void 0===r||isStandardStream(r)||r.destroy()},forwardStdio=r=>{if(r.length>1)return r.some(({value:r})=>"overlapped"===r)?"overlapped":"pipe";let[{type:n,value:a}]=r;return"native"===n?a:"pipe"},handleStdioSync=(r,n)=>handleStdio(eZ,r,n,!0),forbiddenIfSync=({type:r,optionName:n})=>{throwInvalidSyncValue(n,e_[r])},throwInvalidSyncValue=(r,n)=>{throw TypeError(`The \`${r}\` option cannot be ${n} with synchronous methods.`)},eY={generator(){},asyncGenerator:forbiddenIfSync,webStream:forbiddenIfSync,nodeStream:forbiddenIfSync,webTransform:forbiddenIfSync,duplex:forbiddenIfSync,asyncIterable:forbiddenIfSync,native:({optionName:r,value:n})=>(("ipc"===n||"overlapped"===n)&&throwInvalidSyncValue(r,`"${n}"`),{})},eZ={input:{...eY,fileUrl:({value:r})=>({contents:[bufferToUint8Array((0,ex.readFileSync)(r))]}),filePath:({value:{file:r}})=>({contents:[bufferToUint8Array((0,ex.readFileSync)(r))]}),fileNumber:forbiddenIfSync,iterable:({value:r})=>({contents:[...r]}),string:({value:r})=>({contents:[r]}),uint8Array:({value:r})=>({contents:[r]})},output:{...eY,fileUrl:({value:r})=>({path:r}),filePath:({value:{file:r,append:n}})=>({path:r,append:n}),fileNumber:({value:r})=>({path:r}),iterable:forbiddenIfSync,string:forbiddenIfSync,uint8Array:forbiddenIfSync}},stripNewline=(r,{stripFinalNewline:n},a)=>getStripFinalNewline(n,a)&&void 0!==r&&!Array.isArray(r)?strip_final_newline_stripFinalNewline(r):r,getStripFinalNewline=(r,n)=>"all"===n?r[1]||r[2]:r[n];var eX=a(4492);let getSplitLinesGenerator=(r,n,a,s)=>r||a?void 0:initializeSplitLines(n,s),splitLinesSync=(r,n,a)=>a?r.flatMap(r=>splitLinesItemSync(r,n)):splitLinesItemSync(r,n),splitLinesItemSync=(r,n)=>{let{transform:a,final:s}=initializeSplitLines(n,{});return[...a(r),...s()]},initializeSplitLines=(r,n)=>(n.previousChunks="",{transform:splitGenerator.bind(void 0,n,r),final:linesFinal.bind(void 0,n)}),splitGenerator=function*(r,n,a){if("string"!=typeof a){yield a;return}let{previousChunks:s}=r,l=-1;for(let d=0;d<a.length;d+=1)if("\n"===a[d]){let u=getNewlineLength(a,d,n,r),p=a.slice(l+1,d+1-u);s.length>0&&(p=concatString(s,p),s=""),yield p,l=d}l!==a.length-1&&(s=concatString(s,a.slice(l+1))),r.previousChunks=s},getNewlineLength=(r,n,a,s)=>a?0:(s.isWindowsNewline=0!==n&&"\r"===r[n-1],s.isWindowsNewline?2:1),linesFinal=function*({previousChunks:r}){r.length>0&&(yield r)},getAppendNewlineGenerator=({binary:r,preserveNewlines:n,readableObjectMode:a,state:s})=>r||n||a?void 0:{transform:appendNewlineGenerator.bind(void 0,s)},appendNewlineGenerator=function*({isWindowsNewline:r=!1},n){let{unixNewline:a,windowsNewline:s,LF:l,concatBytes:d}="string"==typeof n?eJ:eQ;if(n.at(-1)===l){yield n;return}let u=r?s:a;yield d(n,u)},concatString=(r,n)=>`${r}${n}`,eJ={windowsNewline:"\r\n",unixNewline:"\n",LF:"\n",concatBytes:concatString},eQ={windowsNewline:new Uint8Array([13,10]),unixNewline:new Uint8Array([10]),LF:10,concatBytes:(r,n)=>{let a=new Uint8Array(r.length+n.length);return a.set(r,0),a.set(n,r.length),a}};var e0=a(2254);let getValidateTransformInput=(r,n)=>r?void 0:validateStringTransformInput.bind(void 0,n),validateStringTransformInput=function*(r,n){if("string"!=typeof n&&!isUint8Array(n)&&!e0.Buffer.isBuffer(n))throw TypeError(`The \`${r}\` option's transform must use "objectMode: true" to receive as input: ${typeof n}.`);yield n},getValidateTransformReturn=(r,n)=>r?validateObjectTransformReturn.bind(void 0,n):validateStringTransformReturn.bind(void 0,n),validateObjectTransformReturn=function*(r,n){validateEmptyReturn(r,n),yield n},validateStringTransformReturn=function*(r,n){if(validateEmptyReturn(r,n),"string"!=typeof n&&!isUint8Array(n))throw TypeError(`The \`${r}\` option's function must yield a string or an Uint8Array, not ${typeof n}.`);yield n},validateEmptyReturn=(r,n)=>{if(null==n)throw TypeError(`The \`${r}\` option's function must not call \`yield ${n}\`.
Instead, \`yield\` should either be called with a value, or not be called at all. For example:
  if (condition) { yield value; }`)},getEncodingTransformGenerator=(r,n,a)=>{if(a)return;if(r)return{transform:encodingUint8ArrayGenerator.bind(void 0,new TextEncoder)};let s=new u.StringDecoder(n);return{transform:encodingStringGenerator.bind(void 0,s),final:encodingStringFinal.bind(void 0,s)}},encodingUint8ArrayGenerator=function*(r,n){e0.Buffer.isBuffer(n)?yield bufferToUint8Array(n):"string"==typeof n?yield r.encode(n):yield n},encodingStringGenerator=function*(r,n){yield isUint8Array(n)?r.write(n):n},encodingStringFinal=function*(r){let n=r.end();""!==n&&(yield n)},e1=(0,b.callbackify)(async(r,n,a,s)=>{n.currentIterable=r(...a);try{for await(let r of n.currentIterable)s.push(r)}finally{delete n.currentIterable}}),transformChunk=async function*(r,n,a){if(a===n.length){yield r;return}let{transform:s=identityGenerator}=n[a];for await(let l of s(r))yield*transformChunk(l,n,a+1)},finalChunks=async function*(r){for(let[n,{final:a}]of Object.entries(r))yield*generatorFinalChunks(a,Number(n),r)},generatorFinalChunks=async function*(r,n,a){if(void 0!==r)for await(let s of r())yield*transformChunk(s,a,n+1)},e2=(0,b.callbackify)(async({currentIterable:r},n)=>{if(void 0!==r){await (n?r.throw(n):r.return());return}if(n)throw n}),identityGenerator=function*(r){yield r},pushChunksSync=(r,n,a,s)=>{try{for(let s of r(...n))a.push(s);s()}catch(r){s(r)}},runTransformSync=(r,n)=>[...n.flatMap(n=>[...transformChunkSync(n,r,0)]),...finalChunksSync(r)],transformChunkSync=function*(r,n,a){if(a===n.length){yield r;return}let{transform:s=run_sync_identityGenerator}=n[a];for(let l of s(r))yield*transformChunkSync(l,n,a+1)},finalChunksSync=function*(r){for(let[n,{final:a}]of Object.entries(r))yield*generatorFinalChunksSync(a,Number(n),r)},generatorFinalChunksSync=function*(r,n,a){if(void 0!==r)for(let s of r())yield*transformChunkSync(s,a,n+1)},run_sync_identityGenerator=function*(r){yield r},generatorToStream=({value:r,value:{transform:n,final:a,writableObjectMode:s,readableObjectMode:l},optionName:d},{encoding:u})=>{let p={},m=addInternalGenerators(r,u,d),f=isAsyncGenerator(n),g=isAsyncGenerator(a),y=f?e1.bind(void 0,transformChunk,p):pushChunksSync.bind(void 0,transformChunkSync),b=f||g?e1.bind(void 0,finalChunks,p):pushChunksSync.bind(void 0,finalChunksSync),S=f||g?e2.bind(void 0,p):void 0,w=new eX.Transform({writableObjectMode:s,writableHighWaterMark:(0,eX.getDefaultHighWaterMark)(s),readableObjectMode:l,readableHighWaterMark:(0,eX.getDefaultHighWaterMark)(l),transform(r,n,a){y([r,m,0],this,a)},flush(r){b([m],this,r)},destroy:S});return{stream:w}},runGeneratorsSync=(r,n,a,s)=>{let l=n.filter(({type:r})=>"generator"===r),d=s?l.reverse():l;for(let{value:n,optionName:s}of d){let l=addInternalGenerators(n,a,s);r=runTransformSync(l,r)}return r},addInternalGenerators=({transform:r,final:n,binary:a,writableObjectMode:s,readableObjectMode:l,preserveNewlines:d},u,p)=>{let m={};return[{transform:getValidateTransformInput(s,p)},getEncodingTransformGenerator(a,u,s),getSplitLinesGenerator(a,d,s,m),{transform:r,final:n},{transform:getValidateTransformReturn(l,p)},getAppendNewlineGenerator({binary:a,preserveNewlines:d,readableObjectMode:l,state:m})].filter(Boolean)},addInputOptionsSync=(r,n)=>{for(let a of getInputFdNumbers(r))addInputOptionSync(r,a,n)},getInputFdNumbers=r=>new Set(Object.entries(r).filter(([,{direction:r}])=>"input"===r).map(([r])=>Number(r))),addInputOptionSync=(r,n,a)=>{let{stdioItems:s}=r[n],l=s.filter(({contents:r})=>void 0!==r);if(0===l.length)return;if(0!==n){let[{type:r,optionName:n}]=l;throw TypeError(`Only the \`stdin\` option, not \`${n}\`, can be ${e_[r]} with synchronous methods.`)}let d=l.map(({contents:r})=>r),u=d.map(r=>applySingleInputGeneratorsSync(r,s));a.input=joinToUint8Array(u)},applySingleInputGeneratorsSync=(r,n)=>{let a=runGeneratorsSync(r,n,"utf8",!0);return validateSerializable(a),joinToUint8Array(a)},validateSerializable=r=>{let n=r.find(r=>"string"!=typeof r&&!isUint8Array(r));if(void 0!==n)throw TypeError(`The \`stdin\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${n}.`)},shouldLogOutput=({stdioItems:r,encoding:n,verboseInfo:a,fdNumber:s})=>"all"!==s&&isFullVerbose(a,s)&&!eE.has(n)&&fdUsesVerbose(s)&&(r.some(({type:r,value:n})=>"native"===r&&e8.has(n))||r.every(({type:r})=>ek.has(r))),fdUsesVerbose=r=>1===r||2===r,e8=new Set(["pipe","overlapped"]),logLines=async(r,n,a,s)=>{for await(let l of r)isPipingStream(n)||logLine(l,a,s)},logLinesSync=(r,n,a)=>{for(let s of r)logLine(s,n,a)},isPipingStream=r=>r._readableState.pipes.length>0,logLine=(r,n,a)=>{let s=serializeVerboseMessage(r);verboseLog({type:"output",verboseMessage:s,fdNumber:n,verboseInfo:a})},transformOutputSync=({fileDescriptors:r,syncResult:{output:n},options:a,isMaxBuffer:s,verboseInfo:l})=>{if(null===n)return{output:Array.from({length:3})};let d={},u=new Set([]),p=n.map((n,p)=>transformOutputResultSync({result:n,fileDescriptors:r,fdNumber:p,state:d,outputFiles:u,isMaxBuffer:s,verboseInfo:l},a));return{output:p,...d}},transformOutputResultSync=({result:r,fileDescriptors:n,fdNumber:a,state:s,outputFiles:l,isMaxBuffer:d,verboseInfo:u},{buffer:p,encoding:m,lines:f,stripFinalNewline:g,maxBuffer:y})=>{if(null===r)return;let b=truncateMaxBufferSync(r,d,y),S=bufferToUint8Array(b),{stdioItems:w,objectMode:v}=n[a],E=runOutputGeneratorsSync([S],w,m,s),{serializedResult:O,finalResult:T=O}=serializeChunks({chunks:E,objectMode:v,encoding:m,lines:f,stripFinalNewline:g,fdNumber:a});logOutputSync({serializedResult:O,fdNumber:a,state:s,verboseInfo:u,encoding:m,stdioItems:w,objectMode:v});let x=p[a]?T:void 0;try{return void 0===s.error&&writeToFiles(O,w,l),x}catch(r){return s.error=r,x}},runOutputGeneratorsSync=(r,n,a,s)=>{try{return runGeneratorsSync(r,n,a,!1)}catch(n){return s.error=n,r}},serializeChunks=({chunks:r,objectMode:n,encoding:a,lines:s,stripFinalNewline:l,fdNumber:d})=>{if(n)return{serializedResult:r};if("buffer"===a)return{serializedResult:joinToUint8Array(r)};let u=joinToString(r,a);return s[d]?{serializedResult:u,finalResult:splitLinesSync(u,!l[d],n)}:{serializedResult:u}},logOutputSync=({serializedResult:r,fdNumber:n,state:a,verboseInfo:s,encoding:l,stdioItems:d,objectMode:u})=>{if(!shouldLogOutput({stdioItems:d,encoding:l,verboseInfo:s,fdNumber:n}))return;let p=splitLinesSync(r,!1,u);try{logLinesSync(p,n,s)}catch(r){a.error??=r}},writeToFiles=(r,n,a)=>{for(let{path:s,append:l}of n.filter(({type:r})=>ej.has(r))){let n="string"==typeof s?s:s.toString();l||a.has(n)?(0,ex.appendFileSync)(s,r):(a.add(n),(0,ex.writeFileSync)(s,r))}},getAllSync=([,r,n],a)=>a.all?void 0===r?n:void 0===n?r:Array.isArray(r)?Array.isArray(n)?[...r,...n]:[...r,stripNewline(n,a,"all")]:Array.isArray(n)?[stripNewline(r,a,"all"),...n]:isUint8Array(r)&&isUint8Array(n)?concatUint8Arrays([r,n]):`${r}${n}`:void 0,waitForExit=async(r,n)=>{let[a,s]=await waitForExitOrError(r);return n.isForcefullyTerminated??=!1,[a,s]},waitForExitOrError=async r=>{let[n,a]=await Promise.allSettled([(0,ei.once)(r,"spawn"),(0,ei.once)(r,"exit")]);return"rejected"===n.status?[]:"rejected"===a.status?waitForSubprocessExit(r):a.value},waitForSubprocessExit=async r=>{try{return await (0,ei.once)(r,"exit")}catch{return waitForSubprocessExit(r)}},waitForSuccessfulExit=async r=>{let[n,a]=await r;if(!isSubprocessErrorExit(n,a)&&isFailedExit(n,a))throw new DiscardedError;return[n,a]},isSubprocessErrorExit=(r,n)=>void 0===r&&void 0===n,isFailedExit=(r,n)=>0!==r||null!==n,getExitResultSync=({error:r,status:n,signal:a,output:s},{maxBuffer:l})=>{let d=getResultError(r,n,a),u=d?.code==="ETIMEDOUT",p=isMaxBufferSync(d,s,l);return{resultError:d,exitCode:n,signal:a,timedOut:u,isMaxBuffer:p}},getResultError=(r,n,a)=>void 0!==r?r:isFailedExit(n,a)?new DiscardedError:void 0,execaCoreSync=(r,n,a)=>{let{file:s,commandArguments:l,command:d,escapedCommand:u,startTime:p,verboseInfo:m,options:f,fileDescriptors:g}=handleSyncArguments(r,n,a),y=spawnSubprocessSync({file:s,commandArguments:l,options:f,command:d,escapedCommand:u,verboseInfo:m,fileDescriptors:g,startTime:p});return handleResult(y,m,f)},handleSyncArguments=(r,n,a)=>{let{command:s,escapedCommand:l,startTime:d,verboseInfo:u}=handleCommand(r,n,a),p=normalizeSyncOptions(a),{file:m,commandArguments:f,options:g}=normalizeOptions(r,n,p);validateSyncOptions(g);let y=handleStdioSync(g,u);return{file:m,commandArguments:f,command:s,escapedCommand:l,startTime:d,verboseInfo:u,options:g,fileDescriptors:y}},normalizeSyncOptions=r=>r.node&&!r.ipc?{...r,ipc:!1}:r,validateSyncOptions=({ipc:r,ipcInput:n,detached:a,cancelSignal:s})=>{n&&throwInvalidSyncOption("ipcInput"),r&&throwInvalidSyncOption("ipc: true"),a&&throwInvalidSyncOption("detached: true"),s&&throwInvalidSyncOption("cancelSignal")},throwInvalidSyncOption=r=>{throw TypeError(`The "${r}" option cannot be used with synchronous methods.`)},spawnSubprocessSync=({file:r,commandArguments:n,options:a,command:s,escapedCommand:l,verboseInfo:d,fileDescriptors:u,startTime:p})=>{let m=runSubprocessSync({file:r,commandArguments:n,options:a,command:s,escapedCommand:l,fileDescriptors:u,startTime:p});if(m.failed)return m;let{resultError:f,exitCode:g,signal:y,timedOut:b,isMaxBuffer:S}=getExitResultSync(m,a),{output:w,error:v=f}=transformOutputSync({fileDescriptors:u,syncResult:m,options:a,isMaxBuffer:S,verboseInfo:d}),E=w.map((r,n)=>stripNewline(r,a,n)),O=stripNewline(getAllSync(w,a),a,"all");return getSyncResult({error:v,exitCode:g,signal:y,timedOut:b,isMaxBuffer:S,stdio:E,all:O,options:a,command:s,escapedCommand:l,startTime:p})},runSubprocessSync=({file:r,commandArguments:n,options:a,command:s,escapedCommand:l,fileDescriptors:u,startTime:p})=>{try{addInputOptionsSync(u,a);let s=normalizeSpawnSyncOptions(a);return(0,d.spawnSync)(...concatenateShell(r,n,s))}catch(r){return makeEarlyError({error:r,command:s,escapedCommand:l,fileDescriptors:u,options:a,startTime:p,isSync:!0})}},normalizeSpawnSyncOptions=({encoding:r,maxBuffer:n,...a})=>({...a,encoding:"buffer",maxBuffer:getMaxBufferSync(n)}),getSyncResult=({error:r,exitCode:n,signal:a,timedOut:s,isMaxBuffer:l,stdio:d,all:u,options:p,command:m,escapedCommand:f,startTime:g})=>void 0===r?makeSuccessResult({command:m,escapedCommand:f,stdio:d,all:u,ipcOutput:[],options:p,startTime:g}):makeError({error:r,command:m,escapedCommand:f,timedOut:s,isCanceled:!1,isGracefullyCanceled:!1,isMaxBuffer:l,isForcefullyTerminated:!1,exitCode:n,signal:a,stdio:d,all:u,ipcOutput:[],options:p,startTime:g,isSync:!0}),getOneMessage=({anyProcess:r,channel:n,isSubprocess:a,ipc:s},{reference:l=!0,filter:d}={})=>(validateIpcMethod({methodName:"getOneMessage",isSubprocess:a,ipc:s,isConnected:isConnected(r)}),getOneMessageAsync({anyProcess:r,channel:n,isSubprocess:a,filter:d,reference:l})),getOneMessageAsync=async({anyProcess:r,channel:n,isSubprocess:a,filter:s,reference:l})=>{addReference(n,l);let d=getIpcEmitter(r,n,a),u=new AbortController;try{return await Promise.race([getMessage(d,s,u),get_one_throwOnDisconnect(d,a,u),throwOnStrictError(d,a,u)])}catch(n){throw disconnect(r),n}finally{u.abort(),removeReference(n,l)}},getMessage=async(r,n,{signal:a})=>{if(void 0===n){let[n]=await (0,ei.once)(r,"message",{signal:a});return n}for await(let[s]of(0,ei.on)(r,"message",{signal:a}))if(n(s))return s},get_one_throwOnDisconnect=async(r,n,{signal:a})=>{await (0,ei.once)(r,"disconnect",{signal:a}),throwOnEarlyDisconnect(n)},throwOnStrictError=async(r,n,{signal:a})=>{let[s]=await (0,ei.once)(r,"strict:error",{signal:a});throw getStrictResponseError(s,n)},getEachMessage=({anyProcess:r,channel:n,isSubprocess:a,ipc:s},{reference:l=!0}={})=>loopOnMessages({anyProcess:r,channel:n,isSubprocess:a,ipc:s,shouldAwait:!a,reference:l}),loopOnMessages=({anyProcess:r,channel:n,isSubprocess:a,ipc:s,shouldAwait:l,reference:d})=>{validateIpcMethod({methodName:"getEachMessage",isSubprocess:a,ipc:s,isConnected:isConnected(r)}),addReference(n,d);let u=getIpcEmitter(r,n,a),p=new AbortController,m={};return stopOnDisconnect(r,u,p),abortOnStrictError({ipcEmitter:u,isSubprocess:a,controller:p,state:m}),iterateOnMessages({anyProcess:r,channel:n,ipcEmitter:u,isSubprocess:a,shouldAwait:l,controller:p,state:m,reference:d})},stopOnDisconnect=async(r,n,a)=>{try{await (0,ei.once)(n,"disconnect",{signal:a.signal}),a.abort()}catch{}},abortOnStrictError=async({ipcEmitter:r,isSubprocess:n,controller:a,state:s})=>{try{let[l]=await (0,ei.once)(r,"strict:error",{signal:a.signal});s.error=getStrictResponseError(l,n),a.abort()}catch{}},iterateOnMessages=async function*({anyProcess:r,channel:n,ipcEmitter:a,isSubprocess:s,shouldAwait:l,controller:d,state:u,reference:p}){try{for await(let[r]of(0,ei.on)(a,"message",{signal:d.signal}))throwIfStrictError(u),yield r}catch{throwIfStrictError(u)}finally{d.abort(),removeReference(n,p),s||disconnect(r),l&&await r}},throwIfStrictError=({error:r})=>{if(r)throw r},addIpcMethods=(r,{ipc:n})=>{Object.assign(r,getIpcMethods(r,!1,n))},getIpcMethods=(r,n,a)=>({sendMessage:sendMessage.bind(void 0,{anyProcess:r,channel:r.channel,isSubprocess:n,ipc:a}),getOneMessage:getOneMessage.bind(void 0,{anyProcess:r,channel:r.channel,isSubprocess:n,ipc:a}),getEachMessage:getEachMessage.bind(void 0,{anyProcess:r,channel:r.channel,isSubprocess:n,ipc:a})}),handleEarlyError=({error:r,command:n,escapedCommand:a,fileDescriptors:s,options:l,startTime:u,verboseInfo:p})=>{cleanupCustomStreams(s);let m=new d.ChildProcess;createDummyStreams(m,s),Object.assign(m,{readable,writable,duplex});let f=makeEarlyError({error:r,command:n,escapedCommand:a,fileDescriptors:s,options:l,startTime:u,isSync:!1}),g=handleDummyPromise(f,p,l);return{subprocess:m,promise:g}},createDummyStreams=(r,n)=>{let a=createDummyStream(),s=createDummyStream(),l=createDummyStream(),d=Array.from({length:n.length-3},createDummyStream),u=createDummyStream(),p=[a,s,l,...d];Object.assign(r,{stdin:a,stdout:s,stderr:l,all:u,stdio:p})},createDummyStream=()=>{let r=new eX.PassThrough;return r.end(),r},readable=()=>new eX.Readable({read(){}}),writable=()=>new eX.Writable({write(){}}),duplex=()=>new eX.Duplex({read(){},write(){}}),handleDummyPromise=async(r,n,a)=>handleResult(r,n,a),handleStdioAsync=(r,n)=>handleStdio(e4,r,n,!1),forbiddenIfAsync=({type:r,optionName:n})=>{throw TypeError(`The \`${n}\` option cannot be ${e_[r]}.`)},e3={fileNumber:forbiddenIfAsync,generator:generatorToStream,asyncGenerator:generatorToStream,nodeStream:({value:r})=>({stream:r}),webTransform({value:{transform:r,writableObjectMode:n,readableObjectMode:a}}){let s=eX.Duplex.fromWeb(r,{objectMode:n||a});return{stream:s}},duplex:({value:{transform:r}})=>({stream:r}),native(){}},e4={input:{...e3,fileUrl:({value:r})=>({stream:(0,ex.createReadStream)(r)}),filePath:({value:{file:r}})=>({stream:(0,ex.createReadStream)(r)}),webStream:({value:r})=>({stream:eX.Readable.fromWeb(r)}),iterable:({value:r})=>({stream:eX.Readable.from(r)}),asyncIterable:({value:r})=>({stream:eX.Readable.from(r)}),string:({value:r})=>({stream:eX.Readable.from(r)}),uint8Array:({value:r})=>({stream:eX.Readable.from(e0.Buffer.from(r))})},output:{...e3,fileUrl:({value:r})=>({stream:(0,ex.createWriteStream)(r)}),filePath:({value:{file:r,append:n}})=>({stream:(0,ex.createWriteStream)(r,n?{flags:"a"}:{})}),webStream:({value:r})=>({stream:eX.Writable.fromWeb(r)}),iterable:forbiddenIfAsync,asyncIterable:forbiddenIfAsync,string:forbiddenIfAsync,uint8Array:forbiddenIfAsync}};var e9=a(6402);function mergeStreams(r){if(!Array.isArray(r))throw TypeError(`Expected an array, got \`${typeof r}\`.`);for(let n of r)validateStream(n);let n=r.some(({readableObjectMode:r})=>r),a=getHighWaterMark(r,n),s=new MergedStream({objectMode:n,writableHighWaterMark:a,readableHighWaterMark:a});for(let n of r)s.add(n);return s}let getHighWaterMark=(r,n)=>{if(0===r.length)return(0,eX.getDefaultHighWaterMark)(n);let a=r.filter(({readableObjectMode:r})=>r===n).map(({readableHighWaterMark:r})=>r);return Math.max(...a)};let MergedStream=class MergedStream extends eX.PassThrough{#o;#s;#l;#c;#d;#u;add(r){if(validateStream(r),this.#o.has(r))return;this.#o.add(r),this.#c??=onMergedStreamFinished(this,this.#o,this.#d);let n=endWhenStreamsDone({passThroughStream:this,stream:r,streams:this.#o,ended:this.#s,aborted:this.#l,onFinished:this.#c,unpipeEvent:this.#d});this.#u.set(r,n),r.pipe(this,{end:!1})}async remove(r){if(validateStream(r),!this.#o.has(r))return!1;let n=this.#u.get(r);return void 0!==n&&(this.#u.delete(r),r.unpipe(this),await n,!0)}constructor(...r){super(...r),this.#o=new Set([]),this.#s=new Set([]),this.#l=new Set([]),this.#d=Symbol("unpipe"),this.#u=new WeakMap}};let onMergedStreamFinished=async(r,n,a)=>{updateMaxListeners(r,e6);let s=new AbortController;try{await Promise.race([onMergedStreamEnd(r,s),onInputStreamsUnpipe(r,n,a,s)])}finally{s.abort(),updateMaxListeners(r,-e6)}},onMergedStreamEnd=async(r,{signal:n})=>{try{await (0,e9.finished)(r,{signal:n,cleanup:!0})}catch(n){throw errorOrAbortStream(r,n),n}},onInputStreamsUnpipe=async(r,n,a,{signal:s})=>{for await(let[l]of(0,ei.on)(r,"unpipe",{signal:s}))n.has(l)&&l.emit(a)},validateStream=r=>{if("function"!=typeof r?.pipe)throw TypeError(`Expected a readable stream, got: \`${typeof r}\`.`)},endWhenStreamsDone=async({passThroughStream:r,stream:n,streams:a,ended:s,aborted:l,onFinished:d,unpipeEvent:u})=>{updateMaxListeners(r,e7);let p=new AbortController;try{await Promise.race([afterMergedStreamFinished(d,n,p),onInputStreamEnd({passThroughStream:r,stream:n,streams:a,ended:s,aborted:l,controller:p}),onInputStreamUnpipe({stream:n,streams:a,ended:s,aborted:l,unpipeEvent:u,controller:p})])}finally{p.abort(),updateMaxListeners(r,-e7)}a.size>0&&a.size===s.size+l.size&&(0===s.size&&l.size>0?abortStream(r):endStream(r))},afterMergedStreamFinished=async(r,n,{signal:a})=>{try{await r,a.aborted||abortStream(n)}catch(r){a.aborted||errorOrAbortStream(n,r)}},onInputStreamEnd=async({passThroughStream:r,stream:n,streams:a,ended:s,aborted:l,controller:{signal:d}})=>{try{await (0,e9.finished)(n,{signal:d,cleanup:!0,readable:!0,writable:!1}),a.has(n)&&s.add(n)}catch(s){if(d.aborted||!a.has(n))return;isAbortError(s)?l.add(n):errorStream(r,s)}},onInputStreamUnpipe=async({stream:r,streams:n,ended:a,aborted:s,unpipeEvent:l,controller:{signal:d}})=>{if(await (0,ei.once)(r,l,{signal:d}),!r.readable)return(0,ei.once)(d,"abort",{signal:d});n.delete(r),a.delete(r),s.delete(r)},endStream=r=>{r.writable&&r.end()},errorOrAbortStream=(r,n)=>{isAbortError(n)?abortStream(r):errorStream(r,n)},isAbortError=r=>r?.code==="ERR_STREAM_PREMATURE_CLOSE",abortStream=r=>{(r.readable||r.writable)&&r.destroy()},errorStream=(r,n)=>{r.destroyed||(r.once("error",noop),r.destroy(n))},noop=()=>{},updateMaxListeners=(r,n)=>{let a=r.getMaxListeners();0!==a&&a!==Number.POSITIVE_INFINITY&&r.setMaxListeners(a+n)},e6=2,e7=1,pipeStreams=(r,n)=>{r.pipe(n),onSourceFinish(r,n),onDestinationFinish(r,n)},onSourceFinish=async(r,n)=>{if(!(isStandardStream(r)||isStandardStream(n))){try{await (0,e9.finished)(r,{cleanup:!0,readable:!0,writable:!1})}catch{}endDestinationStream(n)}},endDestinationStream=r=>{r.writable&&r.end()},onDestinationFinish=async(r,n)=>{if(!(isStandardStream(r)||isStandardStream(n))){try{await (0,e9.finished)(n,{cleanup:!0,readable:!1,writable:!0})}catch{}abortSourceStream(r)}},abortSourceStream=r=>{r.readable&&r.destroy()},pipeOutputAsync=(r,n,a)=>{let s=new Map;for(let[l,{stdioItems:d,direction:u}]of Object.entries(n)){for(let{stream:n}of d.filter(({type:r})=>ek.has(r)))pipeTransform(r,n,u,l);for(let{stream:n}of d.filter(({type:r})=>!ek.has(r)))pipeStdioItem({subprocess:r,stream:n,direction:u,fdNumber:l,pipeGroups:s,controller:a})}for(let[r,n]of s.entries()){let a=1===n.length?n[0]:mergeStreams(n);pipeStreams(a,r)}},pipeTransform=(r,n,a,s)=>{"output"===a?pipeStreams(r.stdio[s],n):pipeStreams(n,r.stdio[s]);let l=e5[s];void 0!==l&&(r[l]=n),r.stdio[s]=n},e5=["stdin","stdout","stderr"],pipeStdioItem=({subprocess:r,stream:n,direction:a,fdNumber:s,pipeGroups:l,controller:d})=>{if(void 0===n)return;setStandardStreamMaxListeners(n,d);let[u,p]="output"===a?[n,r.stdio[s]]:[r.stdio[s],n],m=l.get(u)??[];l.set(u,[...m,p])},setStandardStreamMaxListeners=(r,{signal:n})=>{isStandardStream(r)&&incrementMaxListeners(r,te,n)},te=2,tt=[];tt.push("SIGHUP","SIGINT","SIGTERM"),"win32"!==process.platform&&tt.push("SIGALRM","SIGABRT","SIGVTALRM","SIGXCPU","SIGXFSZ","SIGUSR2","SIGTRAP","SIGSYS","SIGQUIT","SIGIOT"),"linux"===process.platform&&tt.push("SIGIO","SIGPOLL","SIGPWR","SIGSTKFLT");let processOk=r=>!!r&&"object"==typeof r&&"function"==typeof r.removeListener&&"function"==typeof r.emit&&"function"==typeof r.reallyExit&&"function"==typeof r.listeners&&"function"==typeof r.kill&&"number"==typeof r.pid&&"function"==typeof r.on,tr=Symbol.for("signal-exit emitter"),tn=globalThis,ti=Object.defineProperty.bind(Object);let Emitter=class Emitter{constructor(){if(this.emitted={afterExit:!1,exit:!1},this.listeners={afterExit:[],exit:[]},this.count=0,this.id=Math.random(),tn[tr])return tn[tr];ti(tn,tr,{value:this,writable:!1,enumerable:!1,configurable:!1})}on(r,n){this.listeners[r].push(n)}removeListener(r,n){let a=this.listeners[r],s=a.indexOf(n);-1!==s&&(0===s&&1===a.length?a.length=0:a.splice(s,1))}emit(r,n,a){if(this.emitted[r])return!1;this.emitted[r]=!0;let s=!1;for(let l of this.listeners[r])s=!0===l(n,a)||s;return"exit"===r&&(s=this.emit("afterExit",n,a)||s),s}};let SignalExitBase=class SignalExitBase{};let SignalExitFallback=class SignalExitFallback extends SignalExitBase{onExit(){return()=>{}}load(){}unload(){}};let SignalExit=class SignalExit extends SignalExitBase{#p;#m;#f;#h;#g;#y;#b;constructor(r){for(let n of(super(),this.#p="win32"===ta.platform?"SIGINT":"SIGHUP",this.#m=new Emitter,this.#y={},this.#b=!1,this.#f=r,this.#y={},tt))this.#y[n]=()=>{let a=this.#f.listeners(n),{count:s}=this.#m;if("object"==typeof r.__signal_exit_emitter__&&"number"==typeof r.__signal_exit_emitter__.count&&(s+=r.__signal_exit_emitter__.count),a.length===s){this.unload();let a=this.#m.emit("exit",null,n),s="SIGHUP"===n?this.#p:n;a||r.kill(r.pid,s)}};this.#g=r.reallyExit,this.#h=r.emit}onExit(r,n){if(!processOk(this.#f))return()=>{};!1===this.#b&&this.load();let a=n?.alwaysLast?"afterExit":"exit";return this.#m.on(a,r),()=>{this.#m.removeListener(a,r),0===this.#m.listeners.exit.length&&0===this.#m.listeners.afterExit.length&&this.unload()}}load(){if(!this.#b){for(let r of(this.#b=!0,this.#m.count+=1,tt))try{let n=this.#y[r];n&&this.#f.on(r,n)}catch(r){}this.#f.emit=(r,...n)=>this.#S(r,...n),this.#f.reallyExit=r=>this.#w(r)}}unload(){this.#b&&(this.#b=!1,tt.forEach(r=>{let n=this.#y[r];if(!n)throw Error("Listener not defined for signal: "+r);try{this.#f.removeListener(r,n)}catch(r){}}),this.#f.emit=this.#h,this.#f.reallyExit=this.#g,this.#m.count-=1)}#w(r){return processOk(this.#f)?(this.#f.exitCode=r||0,this.#m.emit("exit",this.#f.exitCode,null),this.#g.call(this.#f,this.#f.exitCode)):0}#S(r,...n){let a=this.#h;if(!("exit"===r&&processOk(this.#f)))return a.call(this.#f,r,...n);{"number"==typeof n[0]&&(this.#f.exitCode=n[0]);let s=a.call(this.#f,r,...n);return this.#m.emit("exit",this.#f.exitCode,null),s}}};let ta=globalThis.process,{onExit:to,load:ts,unload:tl}=(s=processOk(ta)?new SignalExit(ta):new SignalExitFallback,{onExit:(r,n)=>s.onExit(r,n),load:()=>s.load(),unload:()=>s.unload()}),cleanupOnExit=(r,{cleanup:n,detached:a},{signal:s})=>{if(!n||a)return;let l=to(()=>{r.kill()});(0,ei.addAbortListener)(s,()=>{l()})},normalizePipeArguments=({source:r,sourcePromise:n,boundOptions:a,createNested:s},...l)=>{let d=getStartTime(),{destination:u,destinationStream:p,destinationError:m,from:f,unpipeSignal:g}=getDestinationStream(a,s,l),{sourceStream:y,sourceError:b}=getSourceStream(r,f),{options:S,fileDescriptors:w}=es.get(r);return{sourcePromise:n,sourceStream:y,sourceOptions:S,sourceError:b,destination:u,destinationStream:p,destinationError:m,unpipeSignal:g,fileDescriptors:w,startTime:d}},getDestinationStream=(r,n,a)=>{try{let{destination:s,pipeOptions:{from:l,to:d,unpipeSignal:u}={}}=getDestination(r,n,...a),p=getToStream(s,d);return{destination:s,destinationStream:p,from:l,unpipeSignal:u}}catch(r){return{destinationError:r}}},getDestination=(r,n,a,...s)=>{if(Array.isArray(a)){let l=n(mapDestinationArguments,r)(a,...s);return{destination:l,pipeOptions:r}}if("string"==typeof a||a instanceof URL||isDenoExecPath(a)){if(Object.keys(r).length>0)throw TypeError('Please use .pipe("file", ..., options) or .pipe(execa("file", ..., options)) instead of .pipe(options)("file", ...).');let[l,d,u]=normalizeParameters(a,...s),p=n(mapDestinationArguments)(l,d,u);return{destination:p,pipeOptions:u}}if(es.has(a)){if(Object.keys(r).length>0)throw TypeError("Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).");return{destination:a,pipeOptions:s[0]}}throw TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${a}`)},mapDestinationArguments=({options:r})=>({options:{...r,stdin:"pipe",piped:!0}}),getSourceStream=(r,n)=>{try{let a=getFromStream(r,n);return{sourceStream:a}}catch(r){return{sourceError:r}}},handlePipeArgumentsError=({sourceStream:r,sourceError:n,destinationStream:a,destinationError:s,fileDescriptors:l,sourceOptions:d,startTime:u})=>{let p=getPipeArgumentsError({sourceStream:r,sourceError:n,destinationStream:a,destinationError:s});if(void 0!==p)throw createNonCommandError({error:p,fileDescriptors:l,sourceOptions:d,startTime:u})},getPipeArgumentsError=({sourceStream:r,sourceError:n,destinationStream:a,destinationError:s})=>void 0!==n&&void 0!==s?s:void 0!==s?(abortSourceStream(r),s):void 0!==n?(endDestinationStream(a),n):void 0,createNonCommandError=({error:r,fileDescriptors:n,sourceOptions:a,startTime:s})=>makeEarlyError({error:r,command:tc,escapedCommand:tc,fileDescriptors:n,options:a,startTime:s,isSync:!1}),tc="source.pipe(destination)",waitForBothSubprocesses=async r=>{let[{status:n,reason:a,value:s=a},{status:l,reason:d,value:u=d}]=await r;if(u.pipedFrom.includes(s)||u.pipedFrom.push(s),"rejected"===l)throw u;if("rejected"===n)throw s;return u},pipeSubprocessStream=(r,n,a)=>{let s=td.has(n)?pipeMoreSubprocessStream(r,n):pipeFirstSubprocessStream(r,n);return incrementMaxListeners(r,tu,a.signal),incrementMaxListeners(n,tp,a.signal),cleanupMergedStreamsMap(n),s},pipeFirstSubprocessStream=(r,n)=>{let a=mergeStreams([r]);return pipeStreams(a,n),td.set(n,a),a},pipeMoreSubprocessStream=(r,n)=>{let a=td.get(n);return a.add(r),a},cleanupMergedStreamsMap=async r=>{try{await (0,e9.finished)(r,{cleanup:!0,readable:!1,writable:!0})}catch{}td.delete(r)},td=new WeakMap,tu=2,tp=1,unpipeOnAbort=(r,n)=>void 0===r?[]:[unpipeOnSignalAbort(r,n)],unpipeOnSignalAbort=async(r,{sourceStream:n,mergedStream:a,fileDescriptors:s,sourceOptions:l,startTime:d})=>{await (0,b.aborted)(r,n),await a.remove(n);let u=Error("Pipe canceled by `unpipeSignal` option.");throw createNonCommandError({error:u,fileDescriptors:s,sourceOptions:l,startTime:d})},pipeToSubprocess=(r,...n)=>{if(isPlainObject(n[0]))return pipeToSubprocess.bind(void 0,{...r,boundOptions:{...r.boundOptions,...n[0]}});let{destination:a,...s}=normalizePipeArguments(r,...n),l=handlePipePromise({...s,destination:a});return l.pipe=pipeToSubprocess.bind(void 0,{...r,source:a,sourcePromise:l,boundOptions:{}}),l},handlePipePromise=async({sourcePromise:r,sourceStream:n,sourceOptions:a,sourceError:s,destination:l,destinationStream:d,destinationError:u,unpipeSignal:p,fileDescriptors:m,startTime:f})=>{let g=getSubprocessPromises(r,l);handlePipeArgumentsError({sourceStream:n,sourceError:s,destinationStream:d,destinationError:u,fileDescriptors:m,sourceOptions:a,startTime:f});let y=new AbortController;try{let r=pipeSubprocessStream(n,d,y);return await Promise.race([waitForBothSubprocesses(g),...unpipeOnAbort(p,{sourceStream:n,mergedStream:r,sourceOptions:a,fileDescriptors:m,startTime:f})])}finally{y.abort()}},getSubprocessPromises=(r,n)=>Promise.allSettled([r,n]),utils_identity=r=>r,utils_noop=()=>void 0,getContentsProperty=({contents:r})=>r,throwObjectStream=r=>{throw Error(`Streams in object mode are not supported: ${String(r)}`)},getLengthProperty=r=>r.length;async function getStreamAsArray(r,n){return getStreamContents(r,tm,n)}let tm={init:()=>({contents:[]}),convertChunk:{string:utils_identity,buffer:utils_identity,arrayBuffer:utils_identity,dataView:utils_identity,typedArray:utils_identity,others:utils_identity},getSize:()=>1,truncateChunk:utils_noop,addChunk:(r,{contents:n})=>(n.push(r),n),getFinalChunk:utils_noop,finalize:getContentsProperty};async function getStreamAsArrayBuffer(r,n){return getStreamContents(r,tg,n)}let tf=new TextEncoder,useUint8Array=r=>new Uint8Array(r),useUint8ArrayWithOffset=r=>new Uint8Array(r.buffer,r.byteOffset,r.byteLength),resizeArrayBufferSlow=(r,n)=>{if(n<=r.byteLength)return r;let a=new ArrayBuffer(getNewContentsLength(n));return new Uint8Array(a).set(new Uint8Array(r),0),a},resizeArrayBuffer=(r,n)=>{if(n<=r.maxByteLength)return r.resize(n),r;let a=new ArrayBuffer(n,{maxByteLength:getNewContentsLength(n)});return new Uint8Array(a).set(new Uint8Array(r),0),a},getNewContentsLength=r=>th**Math.ceil(Math.log(r)/Math.log(th)),th=2,hasArrayBufferResize=()=>"resize"in ArrayBuffer.prototype,tg={init:()=>({contents:new ArrayBuffer(0)}),convertChunk:{string:r=>tf.encode(r),buffer:useUint8Array,arrayBuffer:useUint8Array,dataView:useUint8ArrayWithOffset,typedArray:useUint8ArrayWithOffset,others:throwObjectStream},getSize:getLengthProperty,truncateChunk:(r,n)=>r.slice(0,n),addChunk:(r,{contents:n,length:a},s)=>{let l=hasArrayBufferResize()?resizeArrayBuffer(n,s):resizeArrayBufferSlow(n,s);return new Uint8Array(l).set(r,a),l},getFinalChunk:utils_noop,finalize:({contents:r,length:n})=>hasArrayBufferResize()?r:r.slice(0,n)};async function getStreamAsString(r,n){return getStreamContents(r,ty,n)}let useTextDecoder=(r,{textDecoder:n})=>n.decode(r,{stream:!0}),ty={init:()=>({contents:"",textDecoder:new TextDecoder}),convertChunk:{string:utils_identity,buffer:useTextDecoder,arrayBuffer:useTextDecoder,dataView:useTextDecoder,typedArray:useTextDecoder,others:throwObjectStream},getSize:getLengthProperty,truncateChunk:(r,n)=>r.slice(0,n),addChunk:(r,{contents:n})=>n+r,getFinalChunk:({textDecoder:r})=>{let n=r.decode();return""===n?void 0:n},finalize:getContentsProperty},iterateOnSubprocessStream=({subprocessStdout:r,subprocess:n,binary:a,shouldEncode:s,encoding:l,preserveNewlines:d})=>{let u=new AbortController;return stopReadingOnExit(n,u),iterateOnStream({stream:r,controller:u,binary:a,shouldEncode:!r.readableObjectMode&&s,encoding:l,shouldSplit:!r.readableObjectMode,preserveNewlines:d})},stopReadingOnExit=async(r,n)=>{try{await r}catch{}finally{n.abort()}},iterateForResult=({stream:r,onStreamEnd:n,lines:a,encoding:s,stripFinalNewline:l,allMixed:d})=>{let u=new AbortController;stopReadingOnStreamEnd(n,u,r);let p=r.readableObjectMode&&!d;return iterateOnStream({stream:r,controller:u,binary:"buffer"===s,shouldEncode:!p,encoding:s,shouldSplit:!p&&a,preserveNewlines:!l})},stopReadingOnStreamEnd=async(r,n,a)=>{try{await r}catch{a.destroy()}finally{n.abort()}},iterateOnStream=({stream:r,controller:n,binary:a,shouldEncode:s,encoding:l,shouldSplit:d,preserveNewlines:u})=>{let p=(0,ei.on)(r,"data",{signal:n.signal,highWaterMark:tS,highWatermark:tS});return iterateOnData({onStdoutChunk:p,controller:n,binary:a,shouldEncode:s,encoding:l,shouldSplit:d,preserveNewlines:u})},tb=(0,eX.getDefaultHighWaterMark)(!0),tS=tb,iterateOnData=async function*({onStdoutChunk:r,controller:n,binary:a,shouldEncode:s,encoding:l,shouldSplit:d,preserveNewlines:u}){let p=getGenerators({binary:a,shouldEncode:s,encoding:l,shouldSplit:d,preserveNewlines:u});try{for await(let[n]of r)yield*transformChunkSync(n,p,0)}catch(r){if(!n.signal.aborted)throw r}finally{yield*finalChunksSync(p)}},getGenerators=({binary:r,shouldEncode:n,encoding:a,shouldSplit:s,preserveNewlines:l})=>[getEncodingTransformGenerator(r,a,!n),getSplitLinesGenerator(r,l,!s,{})].filter(Boolean),getStreamOutput=async({stream:r,onStreamEnd:n,fdNumber:a,encoding:s,buffer:l,maxBuffer:d,lines:u,allMixed:p,stripFinalNewline:m,verboseInfo:f,streamInfo:g})=>{let y=logOutputAsync({stream:r,onStreamEnd:n,fdNumber:a,encoding:s,allMixed:p,verboseInfo:f,streamInfo:g});if(!l){await Promise.all([resumeStream(r),y]);return}let b=getStripFinalNewline(m,a),S=iterateForResult({stream:r,onStreamEnd:n,lines:u,encoding:s,stripFinalNewline:b,allMixed:p}),[w]=await Promise.all([contents_getStreamContents({stream:r,iterable:S,fdNumber:a,encoding:s,maxBuffer:d,lines:u}),y]);return w},logOutputAsync=async({stream:r,onStreamEnd:n,fdNumber:a,encoding:s,allMixed:l,verboseInfo:d,streamInfo:{fileDescriptors:u}})=>{if(!shouldLogOutput({stdioItems:u[a]?.stdioItems,encoding:s,verboseInfo:d,fdNumber:a}))return;let p=iterateForResult({stream:r,onStreamEnd:n,lines:!0,encoding:s,stripFinalNewline:!0,allMixed:l});await logLines(p,r,a,d)},resumeStream=async r=>{await (0,Y.setImmediate)(),null===r.readableFlowing&&r.resume()},contents_getStreamContents=async({stream:r,stream:{readableObjectMode:n},iterable:a,fdNumber:s,encoding:l,maxBuffer:d,lines:u})=>{try{if(n||u)return await getStreamAsArray(a,{maxBuffer:d});if("buffer"===l)return new Uint8Array(await getStreamAsArrayBuffer(a,{maxBuffer:d}));return await getStreamAsString(a,{maxBuffer:d})}catch(a){return handleBufferedData(handleMaxBuffer({error:a,stream:r,readableObjectMode:n,lines:u,encoding:l,fdNumber:s}))}},getBufferedData=async r=>{try{return await r}catch(r){return handleBufferedData(r)}},handleBufferedData=({bufferedData:r})=>isArrayBuffer(r)?new Uint8Array(r):r,waitForStream=async(r,n,a,{isSameDirection:s,stopOnExit:l=!1}={})=>{let d=handleStdinDestroy(r,a),u=new AbortController;try{await Promise.race([...l?[a.exitPromise]:[],(0,e9.finished)(r,{cleanup:!0,signal:u.signal})])}catch(r){d.stdinCleanedUp||handleStreamError(r,n,a,s)}finally{u.abort()}},handleStdinDestroy=(r,{originalStreams:[n],subprocess:a})=>{let s={stdinCleanedUp:!1};return r===n&&spyOnStdinDestroy(r,a,s),s},spyOnStdinDestroy=(r,n,a)=>{let{_destroy:s}=r;r._destroy=(...l)=>{setStdinCleanedUp(n,a),s.call(r,...l)}},setStdinCleanedUp=({exitCode:r,signalCode:n},a)=>{(null!==r||null!==n)&&(a.stdinCleanedUp=!0)},handleStreamError=(r,n,a,s)=>{if(!shouldIgnoreStreamError(r,n,a,s))throw r},shouldIgnoreStreamError=(r,n,a,s=!0)=>a.propagating?isStreamEpipe(r)||isStreamAbort(r):(a.propagating=!0,isInputFileDescriptor(a,n)===s?isStreamEpipe(r):isStreamAbort(r)),isInputFileDescriptor=({fileDescriptors:r},n)=>"all"!==n&&"input"===r[n].direction,isStreamAbort=r=>r?.code==="ERR_STREAM_PREMATURE_CLOSE",isStreamEpipe=r=>r?.code==="EPIPE",waitForStdioStreams=({subprocess:r,encoding:n,buffer:a,maxBuffer:s,lines:l,stripFinalNewline:d,verboseInfo:u,streamInfo:p})=>r.stdio.map((r,m)=>waitForSubprocessStream({stream:r,fdNumber:m,encoding:n,buffer:a[m],maxBuffer:s[m],lines:l[m],allMixed:!1,stripFinalNewline:d,verboseInfo:u,streamInfo:p})),waitForSubprocessStream=async({stream:r,fdNumber:n,encoding:a,buffer:s,maxBuffer:l,lines:d,allMixed:u,stripFinalNewline:p,verboseInfo:m,streamInfo:f})=>{if(!r)return;let g=waitForStream(r,n,f);if(isInputFileDescriptor(f,n)){await g;return}let[y]=await Promise.all([getStreamOutput({stream:r,onStreamEnd:g,fdNumber:n,encoding:a,buffer:s,maxBuffer:l,lines:d,allMixed:u,stripFinalNewline:p,verboseInfo:m,streamInfo:f}),g]);return y},makeAllStream=({stdout:r,stderr:n},{all:a})=>a&&(r||n)?mergeStreams([r,n].filter(Boolean)):void 0,waitForAllStream=({subprocess:r,encoding:n,buffer:a,maxBuffer:s,lines:l,stripFinalNewline:d,verboseInfo:u,streamInfo:p})=>waitForSubprocessStream({...getAllStream(r,a),fdNumber:"all",encoding:n,maxBuffer:s[1]+s[2],lines:l[1]||l[2],allMixed:getAllMixed(r),stripFinalNewline:d,verboseInfo:u,streamInfo:p}),getAllStream=({stdout:r,stderr:n,all:a},[,s,l])=>{let d=s||l;return d?s?l?{stream:a,buffer:d}:{stream:r,buffer:d}:{stream:n,buffer:d}:{stream:a,buffer:d}},getAllMixed=({all:r,stdout:n,stderr:a})=>r&&n&&a&&n.readableObjectMode!==a.readableObjectMode,shouldLogIpc=r=>isFullVerbose(r,"ipc"),logIpcOutput=(r,n)=>{let a=serializeVerboseMessage(r);verboseLog({type:"ipc",verboseMessage:a,fdNumber:"ipc",verboseInfo:n})},waitForIpcOutput=async({subprocess:r,buffer:n,maxBuffer:a,ipc:s,ipcOutput:l,verboseInfo:d})=>{if(!s)return l;let u=shouldLogIpc(d),p=getFdSpecificValue(n,"ipc"),m=getFdSpecificValue(a,"ipc");for await(let n of loopOnMessages({anyProcess:r,channel:r.channel,isSubprocess:!1,ipc:s,shouldAwait:!1,reference:!0}))p&&(checkIpcMaxBuffer(r,l,m),l.push(n)),u&&logIpcOutput(n,d);return l},getBufferedIpcOutput=async(r,n)=>(await Promise.allSettled([r]),n),waitForSubprocessResult=async({subprocess:r,options:{encoding:n,buffer:a,maxBuffer:s,lines:l,timeoutDuration:d,cancelSignal:u,gracefulCancel:p,forceKillAfterDelay:m,stripFinalNewline:f,ipc:g,ipcInput:y},context:b,verboseInfo:S,fileDescriptors:w,originalStreams:v,onInternalError:E,controller:O})=>{let T=waitForExit(r,b),x={originalStreams:v,fileDescriptors:w,subprocess:r,exitPromise:T,propagating:!1},D=waitForStdioStreams({subprocess:r,encoding:n,buffer:a,maxBuffer:s,lines:l,stripFinalNewline:f,verboseInfo:S,streamInfo:x}),I=waitForAllStream({subprocess:r,encoding:n,buffer:a,maxBuffer:s,lines:l,stripFinalNewline:f,verboseInfo:S,streamInfo:x}),A=[],M=waitForIpcOutput({subprocess:r,buffer:a,maxBuffer:s,ipc:g,ipcOutput:A,verboseInfo:S}),F=waitForOriginalStreams(v,r,x),R=waitForCustomStreamsEnd(w,x);try{return await Promise.race([Promise.all([{},waitForSuccessfulExit(T),Promise.all(D),I,M,sendIpcInput(r,y),...F,...R]),E,throwOnSubprocessError(r,O),...throwOnTimeout(r,d,b,O),...throwOnCancel({subprocess:r,cancelSignal:u,gracefulCancel:p,context:b,controller:O}),...throwOnGracefulCancel({subprocess:r,cancelSignal:u,gracefulCancel:p,forceKillAfterDelay:m,context:b,controller:O})])}catch(r){return b.terminationReason??="other",Promise.all([{error:r},T,Promise.all(D.map(r=>getBufferedData(r))),getBufferedData(I),getBufferedIpcOutput(M,A),Promise.allSettled(F),Promise.allSettled(R)])}},waitForOriginalStreams=(r,n,a)=>r.map((r,s)=>r===n.stdio[s]?void 0:waitForStream(r,s,a)),waitForCustomStreamsEnd=(r,n)=>r.flatMap(({stdioItems:r},a)=>r.filter(({value:r,stream:n=r})=>isStream(n,{checkOpen:!1})&&!isStandardStream(n)).map(({type:r,value:s,stream:l=s})=>waitForStream(l,a,n,{isSameDirection:ek.has(r),stopOnExit:"native"===r}))),throwOnSubprocessError=async(r,{signal:n})=>{let[a]=await (0,ei.once)(r,"error",{signal:n});throw a},initializeConcurrentStreams=()=>({readableDestroy:new WeakMap,writableFinal:new WeakMap,writableDestroy:new WeakMap}),addConcurrentStream=(r,n,a)=>{let s=r[a];s.has(n)||s.set(n,[]);let l=s.get(n),d=createDeferred();l.push(d);let u=d.resolve.bind(d);return{resolve:u,promises:l}},waitForConcurrentStreams=async({resolve:r,promises:n},a)=>{r();let[s]=await Promise.race([Promise.allSettled([!0,a]),Promise.all([!1,...n])]);return!s},safeWaitForSubprocessStdin=async r=>{if(void 0!==r)try{await waitForSubprocessStdin(r)}catch{}},safeWaitForSubprocessStdout=async r=>{if(void 0!==r)try{await waitForSubprocessStdout(r)}catch{}},waitForSubprocessStdin=async r=>{await (0,e9.finished)(r,{cleanup:!0,readable:!1,writable:!0})},waitForSubprocessStdout=async r=>{await (0,e9.finished)(r,{cleanup:!0,readable:!0,writable:!1})},waitForSubprocess=async(r,n)=>{if(await r,n)throw n},destroyOtherStream=(r,n,a)=>{a&&!isStreamAbort(a)?r.destroy(a):n&&r.destroy()},createReadable=({subprocess:r,concurrentStreams:n,encoding:a},{from:s,binary:l=!0,preserveNewlines:d=!0}={})=>{let u=l||eE.has(a),{subprocessStdout:p,waitReadableDestroy:m}=getSubprocessStdout(r,s,n),{readableEncoding:f,readableObjectMode:g,readableHighWaterMark:y}=getReadableOptions(p,u),{read:S,onStdoutDataDone:w}=getReadableMethods({subprocessStdout:p,subprocess:r,binary:u,encoding:a,preserveNewlines:d}),v=new eX.Readable({read:S,destroy:(0,b.callbackify)(onReadableDestroy.bind(void 0,{subprocessStdout:p,subprocess:r,waitReadableDestroy:m})),highWaterMark:y,objectMode:g,encoding:f});return onStdoutFinished({subprocessStdout:p,onStdoutDataDone:w,readable:v,subprocess:r}),v},getSubprocessStdout=(r,n,a)=>{let s=getFromStream(r,n),l=addConcurrentStream(a,s,"readableDestroy");return{subprocessStdout:s,waitReadableDestroy:l}},getReadableOptions=({readableEncoding:r,readableObjectMode:n,readableHighWaterMark:a},s)=>s?{readableEncoding:r,readableObjectMode:n,readableHighWaterMark:a}:{readableEncoding:r,readableObjectMode:!0,readableHighWaterMark:tb},getReadableMethods=({subprocessStdout:r,subprocess:n,binary:a,encoding:s,preserveNewlines:l})=>{let d=createDeferred(),u=iterateOnSubprocessStream({subprocessStdout:r,subprocess:n,binary:a,shouldEncode:!a,encoding:s,preserveNewlines:l});return{read(){onRead(this,u,d)},onStdoutDataDone:d}},onRead=async(r,n,a)=>{try{let{value:s,done:l}=await n.next();l?a.resolve():r.push(s)}catch{}},onStdoutFinished=async({subprocessStdout:r,onStdoutDataDone:n,readable:a,subprocess:s,subprocessStdin:l})=>{try{await waitForSubprocessStdout(r),await s,await safeWaitForSubprocessStdin(l),await n,a.readable&&a.push(null)}catch(r){await safeWaitForSubprocessStdin(l),destroyOtherReadable(a,r)}},onReadableDestroy=async({subprocessStdout:r,subprocess:n,waitReadableDestroy:a},s)=>{await waitForConcurrentStreams(a,n)&&(destroyOtherReadable(r,s),await waitForSubprocess(n,s))},destroyOtherReadable=(r,n)=>{destroyOtherStream(r,r.readable,n)},createWritable=({subprocess:r,concurrentStreams:n},{to:a}={})=>{let{subprocessStdin:s,waitWritableFinal:l,waitWritableDestroy:d}=getSubprocessStdin(r,a,n),u=new eX.Writable({...getWritableMethods(s,r,l),destroy:(0,b.callbackify)(onWritableDestroy.bind(void 0,{subprocessStdin:s,subprocess:r,waitWritableFinal:l,waitWritableDestroy:d})),highWaterMark:s.writableHighWaterMark,objectMode:s.writableObjectMode});return onStdinFinished(s,u),u},getSubprocessStdin=(r,n,a)=>{let s=getToStream(r,n),l=addConcurrentStream(a,s,"writableFinal"),d=addConcurrentStream(a,s,"writableDestroy");return{subprocessStdin:s,waitWritableFinal:l,waitWritableDestroy:d}},getWritableMethods=(r,n,a)=>({write:onWrite.bind(void 0,r),final:(0,b.callbackify)(onWritableFinal.bind(void 0,r,n,a))}),onWrite=(r,n,a,s)=>{r.write(n,a)?s():r.once("drain",s)},onWritableFinal=async(r,n,a)=>{await waitForConcurrentStreams(a,n)&&(r.writable&&r.end(),await n)},onStdinFinished=async(r,n,a)=>{try{await waitForSubprocessStdin(r),n.writable&&n.end()}catch(r){await safeWaitForSubprocessStdout(a),destroyOtherWritable(n,r)}},onWritableDestroy=async({subprocessStdin:r,subprocess:n,waitWritableFinal:a,waitWritableDestroy:s},l)=>{await waitForConcurrentStreams(a,n),await waitForConcurrentStreams(s,n)&&(destroyOtherWritable(r,l),await waitForSubprocess(n,l))},destroyOtherWritable=(r,n)=>{destroyOtherStream(r,r.writable,n)},createDuplex=({subprocess:r,concurrentStreams:n,encoding:a},{from:s,to:l,binary:d=!0,preserveNewlines:u=!0}={})=>{let p=d||eE.has(a),{subprocessStdout:m,waitReadableDestroy:f}=getSubprocessStdout(r,s,n),{subprocessStdin:g,waitWritableFinal:y,waitWritableDestroy:S}=getSubprocessStdin(r,l,n),{readableEncoding:w,readableObjectMode:v,readableHighWaterMark:E}=getReadableOptions(m,p),{read:O,onStdoutDataDone:T}=getReadableMethods({subprocessStdout:m,subprocess:r,binary:p,encoding:a,preserveNewlines:u}),x=new eX.Duplex({read:O,...getWritableMethods(g,r,y),destroy:(0,b.callbackify)(onDuplexDestroy.bind(void 0,{subprocessStdout:m,subprocessStdin:g,subprocess:r,waitReadableDestroy:f,waitWritableFinal:y,waitWritableDestroy:S})),readableHighWaterMark:E,writableHighWaterMark:g.writableHighWaterMark,readableObjectMode:v,writableObjectMode:g.writableObjectMode,encoding:w});return onStdoutFinished({subprocessStdout:m,onStdoutDataDone:T,readable:x,subprocess:r,subprocessStdin:g}),onStdinFinished(g,x,m),x},onDuplexDestroy=async({subprocessStdout:r,subprocessStdin:n,subprocess:a,waitReadableDestroy:s,waitWritableFinal:l,waitWritableDestroy:d},u)=>{await Promise.all([onReadableDestroy({subprocessStdout:r,subprocess:a,waitReadableDestroy:s},u),onWritableDestroy({subprocessStdin:n,subprocess:a,waitWritableFinal:l,waitWritableDestroy:d},u)])},createIterable=(r,n,{from:a,binary:s=!1,preserveNewlines:l=!1}={})=>{let d=s||eE.has(n),u=getFromStream(r,a),p=iterateOnSubprocessStream({subprocessStdout:u,subprocess:r,binary:d,shouldEncode:!0,encoding:n,preserveNewlines:l});return iterateOnStdoutData(p,u,r)},iterateOnStdoutData=async function*(r,n,a){try{yield*r}finally{n.readable&&n.destroy(),await a}},addConvertedStreams=(r,{encoding:n})=>{let a=initializeConcurrentStreams();r.readable=createReadable.bind(void 0,{subprocess:r,concurrentStreams:a,encoding:n}),r.writable=createWritable.bind(void 0,{subprocess:r,concurrentStreams:a}),r.duplex=createDuplex.bind(void 0,{subprocess:r,concurrentStreams:a,encoding:n}),r.iterable=createIterable.bind(void 0,r,n),r[Symbol.asyncIterator]=createIterable.bind(void 0,r,n,{})},mergePromise=(r,n)=>{for(let[a,s]of tv){let l=s.value.bind(n);Reflect.defineProperty(r,a,{...s,value:l})}},tw=(async()=>{})().constructor.prototype,tv=["then","catch","finally"].map(r=>[r,Reflect.getOwnPropertyDescriptor(tw,r)]),execaCoreAsync=(r,n,a,s)=>{let{file:l,commandArguments:d,command:u,escapedCommand:p,startTime:m,verboseInfo:f,options:g,fileDescriptors:y}=handleAsyncArguments(r,n,a),{subprocess:b,promise:S}=spawnSubprocessAsync({file:l,commandArguments:d,options:g,startTime:m,verboseInfo:f,command:u,escapedCommand:p,fileDescriptors:y});return b.pipe=pipeToSubprocess.bind(void 0,{source:b,sourcePromise:S,boundOptions:{},createNested:s}),mergePromise(b,S),es.set(b,{options:g,fileDescriptors:y}),b},handleAsyncArguments=(r,n,a)=>{let{command:s,escapedCommand:l,startTime:d,verboseInfo:u}=handleCommand(r,n,a),{file:p,commandArguments:m,options:f}=normalizeOptions(r,n,a),g=handleAsyncOptions(f),y=handleStdioAsync(g,u);return{file:p,commandArguments:m,command:s,escapedCommand:l,startTime:d,verboseInfo:u,options:g,fileDescriptors:y}},handleAsyncOptions=({timeout:r,signal:n,...a})=>{if(void 0!==n)throw TypeError('The "signal" option has been renamed to "cancelSignal" instead.');return{...a,timeoutDuration:r}},spawnSubprocessAsync=({file:r,commandArguments:n,options:a,startTime:s,verboseInfo:l,command:u,escapedCommand:p,fileDescriptors:m})=>{let f;try{f=(0,d.spawn)(...concatenateShell(r,n,a))}catch(r){return handleEarlyError({error:r,command:u,escapedCommand:p,fileDescriptors:m,options:a,startTime:s,verboseInfo:l})}let g=new AbortController;(0,ei.setMaxListeners)(Number.POSITIVE_INFINITY,g.signal);let y=[...f.stdio];pipeOutputAsync(f,m,g),cleanupOnExit(f,a,g);let b={},S=createDeferred();f.kill=subprocessKill.bind(void 0,{kill:f.kill.bind(f),options:a,onInternalError:S,context:b,controller:g}),f.all=makeAllStream(f,a),addConvertedStreams(f,a),addIpcMethods(f,a);let w=handlePromise({subprocess:f,options:a,startTime:s,verboseInfo:l,fileDescriptors:m,originalStreams:y,command:u,escapedCommand:p,context:b,onInternalError:S,controller:g});return{subprocess:f,promise:w}},handlePromise=async({subprocess:r,options:n,startTime:a,verboseInfo:s,fileDescriptors:l,originalStreams:d,command:u,escapedCommand:p,context:m,onInternalError:f,controller:g})=>{let[y,[b,S],w,v,E]=await waitForSubprocessResult({subprocess:r,options:n,context:m,verboseInfo:s,fileDescriptors:l,originalStreams:d,onInternalError:f,controller:g});g.abort(),f.resolve();let O=w.map((r,a)=>stripNewline(r,n,a)),T=stripNewline(v,n,"all"),x=getAsyncResult({errorInfo:y,exitCode:b,signal:S,stdio:O,all:T,ipcOutput:E,context:m,options:n,command:u,escapedCommand:p,startTime:a});return handleResult(x,s,n)},getAsyncResult=({errorInfo:r,exitCode:n,signal:a,stdio:s,all:l,ipcOutput:d,context:u,options:p,command:m,escapedCommand:f,startTime:g})=>"error"in r?makeError({error:r.error,command:m,escapedCommand:f,timedOut:"timeout"===u.terminationReason,isCanceled:"cancel"===u.terminationReason||"gracefulCancel"===u.terminationReason,isGracefullyCanceled:"gracefulCancel"===u.terminationReason,isMaxBuffer:r.error instanceof MaxBufferError,isForcefullyTerminated:u.isForcefullyTerminated,exitCode:n,signal:a,stdio:s,all:l,ipcOutput:d,options:p,startTime:g,isSync:!1}):makeSuccessResult({command:m,escapedCommand:f,stdio:s,all:l,ipcOutput:d,options:p,startTime:g}),mergeOptions=(r,n)=>{let a=Object.fromEntries(Object.entries(n).map(([n,a])=>[n,mergeOption(n,r[n],a)]));return{...r,...a}},mergeOption=(r,n,a)=>tE.has(r)&&isPlainObject(n)&&isPlainObject(a)?{...n,...a}:a,tE=new Set(["env",...x]),createExeca=(r,n,a,s)=>{let createNested=(r,n,s)=>createExeca(r,n,a,s),boundExeca=(...l)=>callBoundExeca({mapArguments:r,deepOptions:a,boundOptions:n,setBoundExeca:s,createNested},...l);return void 0!==s&&s(boundExeca,createNested,n),boundExeca},callBoundExeca=({mapArguments:r,deepOptions:n={},boundOptions:a={},setBoundExeca:s,createNested:l},d,...u)=>{if(isPlainObject(d))return l(r,mergeOptions(a,d),s);let{file:p,commandArguments:m,options:f,isSync:g}=parseArguments({mapArguments:r,firstArgument:d,nextArguments:u,deepOptions:n,boundOptions:a});return g?execaCoreSync(p,m,f):execaCoreAsync(p,m,f,l)},parseArguments=({mapArguments:r,firstArgument:n,nextArguments:a,deepOptions:s,boundOptions:l})=>{let d=isTemplateString(n)?parseTemplates(n,a):[n,...a],[u,p,m]=normalizeParameters(...d),f=mergeOptions(mergeOptions(s,l),m),{file:g=u,commandArguments:y=p,options:b=f,isSync:S=!1}=r({file:u,commandArguments:p,options:f});return{file:g,commandArguments:y,options:b,isSync:S}},parseCommand=(r,n)=>{if(n.length>0)throw TypeError(`The command and its arguments must be passed as a single string: ${r} ${n}.`);let[a,...s]=parseCommandString(r);return{file:a,commandArguments:s}},parseCommandString=r=>{if("string"!=typeof r)throw TypeError(`The command must be a string: ${String(r)}.`);let n=r.trim();if(""===n)return[];let a=[];for(let r of n.split(tO)){let n=a.at(-1);n&&n.endsWith("\\")?a[a.length-1]=`${n.slice(0,-1)} ${r}`:a.push(r)}return a},tO=/ +/g,mapScriptSync=({options:r})=>({...getScriptOptions(r),isSync:!0}),getScriptOptions=r=>({options:{...getScriptStdinOption(r),...r}}),getScriptStdinOption=({input:r,inputFile:n,stdio:a})=>void 0===r&&void 0===n&&void 0===a?{stdin:"inherit"}:{},tT=createExeca(()=>({}));createExeca(()=>({isSync:!0})),createExeca(({file:r,commandArguments:n})=>parseCommand(r,n)),createExeca(({file:r,commandArguments:n})=>({...parseCommand(r,n),isSync:!0})),createExeca(({options:r})=>{if(!1===r.node)throw TypeError('The "node" option cannot be false with `execaNode()`.');return{options:{...r,node:!0}}}),createExeca(({options:r})=>getScriptOptions(r),{},{preferLocal:!0},(r,n,a)=>{r.sync=n(mapScriptSync,a),r.s=r.sync});let{sendMessage:tx,getOneMessage:tD,getEachMessage:tI,getCancelSignal:tA}=(()=>{let r=void 0!==S.channel;return{...getIpcMethods(S,!0,r),getCancelSignal:getCancelSignal.bind(void 0,{anyProcess:S,channel:S.channel,isSubprocess:!0,ipc:r})}})()}};