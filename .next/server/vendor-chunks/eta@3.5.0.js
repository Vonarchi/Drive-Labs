"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/eta@3.5.0";
exports.ids = ["vendor-chunks/eta@3.5.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/eta@3.5.0/node_modules/eta/dist/eta.module.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/eta@3.5.0/node_modules/eta/dist/eta.module.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Eta: () => (/* binding */ Eta),\n/* harmony export */   EtaError: () => (/* binding */ EtaError),\n/* harmony export */   EtaFileResolutionError: () => (/* binding */ EtaFileResolutionError),\n/* harmony export */   EtaNameResolutionError: () => (/* binding */ EtaNameResolutionError),\n/* harmony export */   EtaParseError: () => (/* binding */ EtaParseError),\n/* harmony export */   EtaRuntimeError: () => (/* binding */ EtaRuntimeError)\n/* harmony export */ });\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n\n\n/**\n * Handles storage and accessing of values\n *\n * In this case, we use it to store compiled template functions\n * Indexed by their `name` or `filename`\n */ class Cacher {\n    constructor(cache){\n        this.cache = void 0;\n        this.cache = cache;\n    }\n    define(key, val) {\n        this.cache[key] = val;\n    }\n    get(key) {\n        return this.cache[key];\n    }\n    remove(key) {\n        delete this.cache[key];\n    }\n    reset() {\n        this.cache = {};\n    }\n    load(cacheObj) {\n        this.cache = {\n            ...this.cache,\n            ...cacheObj\n        };\n    }\n}\nclass EtaError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"Eta Error\";\n    }\n}\nclass EtaParseError extends EtaError {\n    constructor(message){\n        super(message);\n        this.name = \"EtaParser Error\";\n    }\n}\nclass EtaRuntimeError extends EtaError {\n    constructor(message){\n        super(message);\n        this.name = \"EtaRuntime Error\";\n    }\n}\nclass EtaFileResolutionError extends EtaError {\n    constructor(message){\n        super(message);\n        this.name = \"EtaFileResolution Error\";\n    }\n}\nclass EtaNameResolutionError extends EtaError {\n    constructor(message){\n        super(message);\n        this.name = \"EtaNameResolution Error\";\n    }\n}\n/**\n * Throws an EtaError with a nicely formatted error and message showing where in the template the error occurred.\n */ function ParseErr(message, str, indx) {\n    const whitespace = str.slice(0, indx).split(/\\n/);\n    const lineNo = whitespace.length;\n    const colNo = whitespace[lineNo - 1].length + 1;\n    message += \" at line \" + lineNo + \" col \" + colNo + \":\\n\\n\" + \"  \" + str.split(/\\n/)[lineNo - 1] + \"\\n\" + \"  \" + Array(colNo).join(\" \") + \"^\";\n    throw new EtaParseError(message);\n}\nfunction RuntimeErr(originalError, str, lineNo, path) {\n    // code gratefully taken from https://github.com/mde/ejs and adapted\n    const lines = str.split(\"\\n\");\n    const start = Math.max(lineNo - 3, 0);\n    const end = Math.min(lines.length, lineNo + 3);\n    const filename = path;\n    // Error context\n    const context = lines.slice(start, end).map(function(line, i) {\n        const curr = i + start + 1;\n        return (curr == lineNo ? \" >> \" : \"    \") + curr + \"| \" + line;\n    }).join(\"\\n\");\n    const header = filename ? filename + \":\" + lineNo + \"\\n\" : \"line \" + lineNo + \"\\n\";\n    const err = new EtaRuntimeError(header + context + \"\\n\\n\" + originalError.message);\n    err.name = originalError.name; // the original name (e.g. ReferenceError) may be useful\n    throw err;\n}\n/* END TYPES */ /* istanbul ignore next */ const AsyncFunction = (async function() {}).constructor; // eslint-disable-line @typescript-eslint/no-empty-function\n/**\n * Takes a template string and returns a template function that can be called with (data, config)\n *\n * @param str - The template string\n * @param config - A custom configuration object (optional)\n */ function compile(str, options) {\n    const config = this.config;\n    /* ASYNC HANDLING */ // code gratefully taken from https://github.com/mde/ejs and adapted\n    const ctor = options && options.async ? AsyncFunction : Function;\n    /* END ASYNC HANDLING */ try {\n        return new ctor(config.varName, \"options\", this.compileToString.call(this, str, options)); // eslint-disable-line no-new-func\n    } catch (e) {\n        if (e instanceof SyntaxError) {\n            throw new EtaParseError(\"Bad template syntax\\n\\n\" + e.message + \"\\n\" + Array(e.message.length + 1).join(\"=\") + \"\\n\" + this.compileToString.call(this, str, options) + \"\\n\");\n        } else {\n            throw e;\n        }\n    }\n}\n/* TYPES */ /* END TYPES */ /**\n * Compiles a template string to a function string. Most often users just use `compile()`, which calls `compileToString` and creates a new function using the result\n */ function compileToString(str, options) {\n    const config = this.config;\n    const isAsync = options && options.async;\n    const compileBody = this.compileBody;\n    const buffer = this.parse.call(this, str);\n    // note: when the include function passes through options, the only parameter that matters is the filepath parameter\n    let res = `${config.functionHeader}\nlet include = (template, data) => this.render(template, data, options);\nlet includeAsync = (template, data) => this.renderAsync(template, data, options);\n\nlet __eta = {res: \"\", e: this.config.escapeFunction, f: this.config.filterFunction${config.debug ? ', line: 1, templateStr: \"' + str.replace(/\\\\|\"/g, \"\\\\$&\").replace(/\\r\\n|\\n|\\r/g, \"\\\\n\") + '\"' : \"\"}};\n\nfunction layout(path, data) {\n  __eta.layout = path;\n  __eta.layoutData = data;\n}${config.debug ? \"try {\" : \"\"}${config.useWith ? \"with(\" + config.varName + \"||{}){\" : \"\"}\n\n${compileBody.call(this, buffer)}\nif (__eta.layout) {\n  __eta.res = ${isAsync ? \"await includeAsync\" : \"include\"} (__eta.layout, {...${config.varName}, body: __eta.res, ...__eta.layoutData});\n}\n${config.useWith ? \"}\" : \"\"}${config.debug ? \"} catch (e) { this.RuntimeErr(e, __eta.templateStr, __eta.line, options.filepath) }\" : \"\"}\nreturn __eta.res;\n`;\n    if (config.plugins) {\n        for(let i = 0; i < config.plugins.length; i++){\n            const plugin = config.plugins[i];\n            if (plugin.processFnString) {\n                res = plugin.processFnString(res, config);\n            }\n        }\n    }\n    return res;\n}\n/**\n * Loops through the AST generated by `parse` and transform each item into JS calls\n *\n * **Example**\n *\n * ```js\n * let templateAST = ['Hi ', { val: 'it.name', t: 'i' }]\n * compileBody.call(Eta, templateAST)\n * // => \"__eta.res+='Hi '\\n__eta.res+=__eta.e(it.name)\\n\"\n * ```\n */ function compileBody(buff) {\n    const config = this.config;\n    let i = 0;\n    const buffLength = buff.length;\n    let returnStr = \"\";\n    for(i; i < buffLength; i++){\n        const currentBlock = buff[i];\n        if (typeof currentBlock === \"string\") {\n            const str = currentBlock;\n            // we know string exists\n            returnStr += \"__eta.res+='\" + str + \"'\\n\";\n        } else {\n            const type = currentBlock.t; // \"r\", \"e\", or \"i\"\n            let content = currentBlock.val || \"\";\n            if (config.debug) returnStr += \"__eta.line=\" + currentBlock.lineNo + \"\\n\";\n            if (type === \"r\") {\n                // raw\n                if (config.autoFilter) {\n                    content = \"__eta.f(\" + content + \")\";\n                }\n                returnStr += \"__eta.res+=\" + content + \"\\n\";\n            } else if (type === \"i\") {\n                // interpolate\n                if (config.autoFilter) {\n                    content = \"__eta.f(\" + content + \")\";\n                }\n                if (config.autoEscape) {\n                    content = \"__eta.e(\" + content + \")\";\n                }\n                returnStr += \"__eta.res+=\" + content + \"\\n\";\n            } else if (type === \"e\") {\n                // execute\n                returnStr += content + \"\\n\";\n            }\n        }\n    }\n    return returnStr;\n}\n/**\n * Takes a string within a template and trims it, based on the preceding tag's whitespace control and `config.autoTrim`\n */ function trimWS(str, config, wsLeft, wsRight) {\n    let leftTrim;\n    let rightTrim;\n    if (Array.isArray(config.autoTrim)) {\n        // Slightly confusing,\n        // but _}} will trim the left side of the following string\n        leftTrim = config.autoTrim[1];\n        rightTrim = config.autoTrim[0];\n    } else {\n        leftTrim = rightTrim = config.autoTrim;\n    }\n    if (wsLeft || wsLeft === false) {\n        leftTrim = wsLeft;\n    }\n    if (wsRight || wsRight === false) {\n        rightTrim = wsRight;\n    }\n    if (!rightTrim && !leftTrim) {\n        return str;\n    }\n    if (leftTrim === \"slurp\" && rightTrim === \"slurp\") {\n        return str.trim();\n    }\n    if (leftTrim === \"_\" || leftTrim === \"slurp\") {\n        // full slurp\n        str = str.trimStart();\n    } else if (leftTrim === \"-\" || leftTrim === \"nl\") {\n        // nl trim\n        str = str.replace(/^(?:\\r\\n|\\n|\\r)/, \"\");\n    }\n    if (rightTrim === \"_\" || rightTrim === \"slurp\") {\n        // full slurp\n        str = str.trimEnd();\n    } else if (rightTrim === \"-\" || rightTrim === \"nl\") {\n        // nl trim\n        str = str.replace(/(?:\\r\\n|\\n|\\r)$/, \"\");\n    }\n    return str;\n}\n/**\n * A map of special HTML characters to their XML-escaped equivalents\n */ const escMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n};\nfunction replaceChar(s) {\n    return escMap[s];\n}\n/**\n * XML-escapes an input value after converting it to a string\n *\n * @param str - Input value (usually a string)\n * @returns XML-escaped string\n */ function XMLEscape(str) {\n    // To deal with XSS. Based on Escape implementations of Mustache.JS and Marko, then customized.\n    const newStr = String(str);\n    if (/[&<>\"']/.test(newStr)) {\n        return newStr.replace(/[&<>\"']/g, replaceChar);\n    } else {\n        return newStr;\n    }\n}\n/* END TYPES */ /** Eta's base (global) configuration */ const defaultConfig = {\n    autoEscape: true,\n    autoFilter: false,\n    autoTrim: [\n        false,\n        \"nl\"\n    ],\n    cache: false,\n    cacheFilepaths: true,\n    debug: false,\n    escapeFunction: XMLEscape,\n    // default filter function (not used unless enables) just stringifies the input\n    filterFunction: (val)=>String(val),\n    functionHeader: \"\",\n    parse: {\n        exec: \"\",\n        interpolate: \"=\",\n        raw: \"~\"\n    },\n    plugins: [],\n    rmWhitespace: false,\n    tags: [\n        \"<%\",\n        \"%>\"\n    ],\n    useWith: false,\n    varName: \"it\",\n    defaultExtension: \".eta\"\n};\n/* END TYPES */ const templateLitReg = /`(?:\\\\[\\s\\S]|\\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})*}|(?!\\${)[^\\\\`])*`/g;\nconst singleQuoteReg = /'(?:\\\\[\\s\\w\"'\\\\`]|[^\\n\\r'\\\\])*?'/g;\nconst doubleQuoteReg = /\"(?:\\\\[\\s\\w\"'\\\\`]|[^\\n\\r\"\\\\])*?\"/g;\n/** Escape special regular expression characters inside a string */ function escapeRegExp(string) {\n    // From MDN\n    return string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n}\nfunction getLineNo(str, index) {\n    return str.slice(0, index).split(\"\\n\").length;\n}\nfunction parse(str) {\n    const config = this.config;\n    let buffer = [];\n    let trimLeftOfNextStr = false;\n    let lastIndex = 0;\n    const parseOptions = config.parse;\n    if (config.plugins) {\n        for(let i = 0; i < config.plugins.length; i++){\n            const plugin = config.plugins[i];\n            if (plugin.processTemplate) {\n                str = plugin.processTemplate(str, config);\n            }\n        }\n    }\n    /* Adding for EJS compatibility */ if (config.rmWhitespace) {\n        // Code taken directly from EJS\n        // Have to use two separate replaces here as `^` and `$` operators don't\n        // work well with `\\r` and empty lines don't work well with the `m` flag.\n        // Essentially, this replaces the whitespace at the beginning and end of\n        // each line and removes multiple newlines.\n        str = str.replace(/[\\r\\n]+/g, \"\\n\").replace(/^\\s+|\\s+$/gm, \"\");\n    }\n    /* End rmWhitespace option */ templateLitReg.lastIndex = 0;\n    singleQuoteReg.lastIndex = 0;\n    doubleQuoteReg.lastIndex = 0;\n    function pushString(strng, shouldTrimRightOfString) {\n        if (strng) {\n            // if string is truthy it must be of type 'string'\n            strng = trimWS(strng, config, trimLeftOfNextStr, // this will only be false on the first str, the next ones will be null or undefined\n            shouldTrimRightOfString);\n            if (strng) {\n                // replace \\ with \\\\, ' with \\'\n                // we're going to convert all CRLF to LF so it doesn't take more than one replace\n                strng = strng.replace(/\\\\|'/g, \"\\\\$&\").replace(/\\r\\n|\\n|\\r/g, \"\\\\n\");\n                buffer.push(strng);\n            }\n        }\n    }\n    const prefixes = [\n        parseOptions.exec,\n        parseOptions.interpolate,\n        parseOptions.raw\n    ].reduce(function(accumulator, prefix) {\n        if (accumulator && prefix) {\n            return accumulator + \"|\" + escapeRegExp(prefix);\n        } else if (prefix) {\n            // accumulator is falsy\n            return escapeRegExp(prefix);\n        } else {\n            // prefix and accumulator are both falsy\n            return accumulator;\n        }\n    }, \"\");\n    const parseOpenReg = new RegExp(escapeRegExp(config.tags[0]) + \"(-|_)?\\\\s*(\" + prefixes + \")?\\\\s*\", \"g\");\n    const parseCloseReg = new RegExp(\"'|\\\"|`|\\\\/\\\\*|(\\\\s*(-|_)?\" + escapeRegExp(config.tags[1]) + \")\", \"g\");\n    let m;\n    while(m = parseOpenReg.exec(str)){\n        const precedingString = str.slice(lastIndex, m.index);\n        lastIndex = m[0].length + m.index;\n        const wsLeft = m[1];\n        const prefix = m[2] || \"\"; // by default either ~, =, or empty\n        pushString(precedingString, wsLeft);\n        parseCloseReg.lastIndex = lastIndex;\n        let closeTag;\n        let currentObj = false;\n        while(closeTag = parseCloseReg.exec(str)){\n            if (closeTag[1]) {\n                const content = str.slice(lastIndex, closeTag.index);\n                parseOpenReg.lastIndex = lastIndex = parseCloseReg.lastIndex;\n                trimLeftOfNextStr = closeTag[2];\n                const currentType = prefix === parseOptions.exec ? \"e\" : prefix === parseOptions.raw ? \"r\" : prefix === parseOptions.interpolate ? \"i\" : \"\";\n                currentObj = {\n                    t: currentType,\n                    val: content\n                };\n                break;\n            } else {\n                const char = closeTag[0];\n                if (char === \"/*\") {\n                    const commentCloseInd = str.indexOf(\"*/\", parseCloseReg.lastIndex);\n                    if (commentCloseInd === -1) {\n                        ParseErr(\"unclosed comment\", str, closeTag.index);\n                    }\n                    parseCloseReg.lastIndex = commentCloseInd;\n                } else if (char === \"'\") {\n                    singleQuoteReg.lastIndex = closeTag.index;\n                    const singleQuoteMatch = singleQuoteReg.exec(str);\n                    if (singleQuoteMatch) {\n                        parseCloseReg.lastIndex = singleQuoteReg.lastIndex;\n                    } else {\n                        ParseErr(\"unclosed string\", str, closeTag.index);\n                    }\n                } else if (char === '\"') {\n                    doubleQuoteReg.lastIndex = closeTag.index;\n                    const doubleQuoteMatch = doubleQuoteReg.exec(str);\n                    if (doubleQuoteMatch) {\n                        parseCloseReg.lastIndex = doubleQuoteReg.lastIndex;\n                    } else {\n                        ParseErr(\"unclosed string\", str, closeTag.index);\n                    }\n                } else if (char === \"`\") {\n                    templateLitReg.lastIndex = closeTag.index;\n                    const templateLitMatch = templateLitReg.exec(str);\n                    if (templateLitMatch) {\n                        parseCloseReg.lastIndex = templateLitReg.lastIndex;\n                    } else {\n                        ParseErr(\"unclosed string\", str, closeTag.index);\n                    }\n                }\n            }\n        }\n        if (currentObj) {\n            if (config.debug) {\n                currentObj.lineNo = getLineNo(str, m.index);\n            }\n            buffer.push(currentObj);\n        } else {\n            ParseErr(\"unclosed tag\", str, m.index);\n        }\n    }\n    pushString(str.slice(lastIndex, str.length), false);\n    if (config.plugins) {\n        for(let i = 0; i < config.plugins.length; i++){\n            const plugin = config.plugins[i];\n            if (plugin.processAST) {\n                buffer = plugin.processAST(buffer, config);\n            }\n        }\n    }\n    return buffer;\n}\n/* END TYPES */ function handleCache(template, options) {\n    const templateStore = options && options.async ? this.templatesAsync : this.templatesSync;\n    if (this.resolvePath && this.readFile && !template.startsWith(\"@\")) {\n        const templatePath = options.filepath;\n        const cachedTemplate = templateStore.get(templatePath);\n        if (this.config.cache && cachedTemplate) {\n            return cachedTemplate;\n        } else {\n            const templateString = this.readFile(templatePath);\n            const templateFn = this.compile(templateString, options);\n            if (this.config.cache) templateStore.define(templatePath, templateFn);\n            return templateFn;\n        }\n    } else {\n        const cachedTemplate = templateStore.get(template);\n        if (cachedTemplate) {\n            return cachedTemplate;\n        } else {\n            throw new EtaNameResolutionError(\"Failed to get template '\" + template + \"'\");\n        }\n    }\n}\nfunction render(template, // template name or template function\ndata, meta) {\n    let templateFn;\n    const options = {\n        ...meta,\n        async: false\n    };\n    if (typeof template === \"string\") {\n        if (this.resolvePath && this.readFile && !template.startsWith(\"@\")) {\n            options.filepath = this.resolvePath(template, options);\n        }\n        templateFn = handleCache.call(this, template, options);\n    } else {\n        templateFn = template;\n    }\n    const res = templateFn.call(this, data, options);\n    return res;\n}\nfunction renderAsync(template, // template name or template function\ndata, meta) {\n    let templateFn;\n    const options = {\n        ...meta,\n        async: true\n    };\n    if (typeof template === \"string\") {\n        if (this.resolvePath && this.readFile && !template.startsWith(\"@\")) {\n            options.filepath = this.resolvePath(template, options);\n        }\n        templateFn = handleCache.call(this, template, options);\n    } else {\n        templateFn = template;\n    }\n    const res = templateFn.call(this, data, options);\n    // Return a promise\n    return Promise.resolve(res);\n}\nfunction renderString(template, data) {\n    const templateFn = this.compile(template, {\n        async: false\n    });\n    return render.call(this, templateFn, data);\n}\nfunction renderStringAsync(template, data) {\n    const templateFn = this.compile(template, {\n        async: true\n    });\n    return renderAsync.call(this, templateFn, data);\n}\n/* END TYPES */ class Eta$1 {\n    constructor(customConfig){\n        this.config = void 0;\n        this.RuntimeErr = RuntimeErr;\n        this.compile = compile;\n        this.compileToString = compileToString;\n        this.compileBody = compileBody;\n        this.parse = parse;\n        this.render = render;\n        this.renderAsync = renderAsync;\n        this.renderString = renderString;\n        this.renderStringAsync = renderStringAsync;\n        this.filepathCache = {};\n        this.templatesSync = new Cacher({});\n        this.templatesAsync = new Cacher({});\n        // resolvePath takes a relative path from the \"views\" directory\n        this.resolvePath = null;\n        this.readFile = null;\n        if (customConfig) {\n            this.config = {\n                ...defaultConfig,\n                ...customConfig\n            };\n        } else {\n            this.config = {\n                ...defaultConfig\n            };\n        }\n    }\n    // METHODS\n    configure(customConfig) {\n        this.config = {\n            ...this.config,\n            ...customConfig\n        };\n    }\n    withConfig(customConfig) {\n        return {\n            ...this,\n            config: {\n                ...this.config,\n                ...customConfig\n            }\n        };\n    }\n    loadTemplate(name, template, // template string or template function\n    options) {\n        if (typeof template === \"string\") {\n            const templates = options && options.async ? this.templatesAsync : this.templatesSync;\n            templates.define(name, this.compile(template, options));\n        } else {\n            let templates = this.templatesSync;\n            if (template.constructor.name === \"AsyncFunction\" || options && options.async) {\n                templates = this.templatesAsync;\n            }\n            templates.define(name, template);\n        }\n    }\n}\n/* END TYPES */ function readFile(path) {\n    let res = \"\";\n    try {\n        res = node_fs__WEBPACK_IMPORTED_MODULE_1__.readFileSync(path, \"utf8\");\n    // eslint-disable-line @typescript-eslint/no-explicit-any\n    } catch (err) {\n        if ((err == null ? void 0 : err.code) === \"ENOENT\") {\n            throw new EtaFileResolutionError(`Could not find template: ${path}`);\n        } else {\n            throw err;\n        }\n    }\n    return res;\n}\nfunction resolvePath(templatePath, options) {\n    let resolvedFilePath = \"\";\n    const views = this.config.views;\n    if (!views) {\n        throw new EtaFileResolutionError(\"Views directory is not defined\");\n    }\n    const baseFilePath = options && options.filepath;\n    const defaultExtension = this.config.defaultExtension === undefined ? \".eta\" : this.config.defaultExtension;\n    // how we index cached template paths\n    const cacheIndex = JSON.stringify({\n        filename: baseFilePath,\n        path: templatePath,\n        views: this.config.views\n    });\n    templatePath += node_path__WEBPACK_IMPORTED_MODULE_0__.extname(templatePath) ? \"\" : defaultExtension;\n    // if the file was included from another template\n    if (baseFilePath) {\n        // check the cache\n        if (this.config.cacheFilepaths && this.filepathCache[cacheIndex]) {\n            return this.filepathCache[cacheIndex];\n        }\n        const absolutePathTest = absolutePathRegExp.exec(templatePath);\n        if (absolutePathTest && absolutePathTest.length) {\n            const formattedPath = templatePath.replace(/^\\/*|^\\\\*/, \"\");\n            resolvedFilePath = node_path__WEBPACK_IMPORTED_MODULE_0__.join(views, formattedPath);\n        } else {\n            resolvedFilePath = node_path__WEBPACK_IMPORTED_MODULE_0__.join(node_path__WEBPACK_IMPORTED_MODULE_0__.dirname(baseFilePath), templatePath);\n        }\n    } else {\n        resolvedFilePath = node_path__WEBPACK_IMPORTED_MODULE_0__.join(views, templatePath);\n    }\n    if (dirIsChild(views, resolvedFilePath)) {\n        // add resolved path to the cache\n        if (baseFilePath && this.config.cacheFilepaths) {\n            this.filepathCache[cacheIndex] = resolvedFilePath;\n        }\n        return resolvedFilePath;\n    } else {\n        throw new EtaFileResolutionError(`Template '${templatePath}' is not in the views directory`);\n    }\n}\nfunction dirIsChild(parent, dir) {\n    const relative = node_path__WEBPACK_IMPORTED_MODULE_0__.relative(parent, dir);\n    return relative && !relative.startsWith(\"..\") && !node_path__WEBPACK_IMPORTED_MODULE_0__.isAbsolute(relative);\n}\nconst absolutePathRegExp = /^\\\\|^\\//;\nclass Eta extends Eta$1 {\n    constructor(...args){\n        super(...args);\n        this.readFile = readFile;\n        this.resolvePath = resolvePath;\n    }\n}\n //# sourceMappingURL=eta.module.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRhQDMuNS4wL25vZGVfbW9kdWxlcy9ldGEvZGlzdC9ldGEubW9kdWxlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFrQztBQUNKO0FBRTlCOzs7OztDQUtDLEdBQ0QsTUFBTUU7SUFDSkMsWUFBWUMsS0FBSyxDQUFFO1FBQ2pCLElBQUksQ0FBQ0EsS0FBSyxHQUFHLEtBQUs7UUFDbEIsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO0lBQ2Y7SUFDQUMsT0FBT0MsR0FBRyxFQUFFQyxHQUFHLEVBQUU7UUFDZixJQUFJLENBQUNILEtBQUssQ0FBQ0UsSUFBSSxHQUFHQztJQUNwQjtJQUNBQyxJQUFJRixHQUFHLEVBQUU7UUFDUCxPQUFPLElBQUksQ0FBQ0YsS0FBSyxDQUFDRSxJQUFJO0lBQ3hCO0lBQ0FHLE9BQU9ILEdBQUcsRUFBRTtRQUNWLE9BQU8sSUFBSSxDQUFDRixLQUFLLENBQUNFLElBQUk7SUFDeEI7SUFDQUksUUFBUTtRQUNOLElBQUksQ0FBQ04sS0FBSyxHQUFHLENBQUM7SUFDaEI7SUFDQU8sS0FBS0MsUUFBUSxFQUFFO1FBQ2IsSUFBSSxDQUFDUixLQUFLLEdBQUc7WUFDWCxHQUFHLElBQUksQ0FBQ0EsS0FBSztZQUNiLEdBQUdRLFFBQVE7UUFDYjtJQUNGO0FBQ0Y7QUFFQSxNQUFNQyxpQkFBaUJDO0lBQ3JCWCxZQUFZWSxPQUFPLENBQUU7UUFDbkIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUNBLE1BQU1DLHNCQUFzQko7SUFDMUJWLFlBQVlZLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBQ0EsTUFBTUUsd0JBQXdCTDtJQUM1QlYsWUFBWVksT0FBTyxDQUFFO1FBQ25CLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFDQSxNQUFNRywr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QUFlLENBQUMyTDtBQUNwRTtBQUNBLE1BQU1OLHFCQUFxQjtBQUUzQixNQUFNUSxZQUFZMUI7SUFDaEJoSyxZQUFZLEdBQUcyTCxJQUFJLENBQUU7UUFDbkIsS0FBSyxJQUFJQTtRQUNULElBQUksQ0FBQzFDLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRCxXQUFXLEdBQUdBO0lBQ3JCO0FBQ0Y7QUFFeUcsQ0FDekcsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHJpdmUtbGFicy1vcmNoZXN0cmF0b3IvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRhQDMuNS4wL25vZGVfbW9kdWxlcy9ldGEvZGlzdC9ldGEubW9kdWxlLm1qcz9mZTY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHBhdGggZnJvbSAnbm9kZTpwYXRoJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ25vZGU6ZnMnO1xuXG4vKipcbiAqIEhhbmRsZXMgc3RvcmFnZSBhbmQgYWNjZXNzaW5nIG9mIHZhbHVlc1xuICpcbiAqIEluIHRoaXMgY2FzZSwgd2UgdXNlIGl0IHRvIHN0b3JlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uc1xuICogSW5kZXhlZCBieSB0aGVpciBgbmFtZWAgb3IgYGZpbGVuYW1lYFxuICovXG5jbGFzcyBDYWNoZXIge1xuICBjb25zdHJ1Y3RvcihjYWNoZSkge1xuICAgIHRoaXMuY2FjaGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xuICB9XG4gIGRlZmluZShrZXksIHZhbCkge1xuICAgIHRoaXMuY2FjaGVba2V5XSA9IHZhbDtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVba2V5XTtcbiAgfVxuICByZW1vdmUoa2V5KSB7XG4gICAgZGVsZXRlIHRoaXMuY2FjaGVba2V5XTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmNhY2hlID0ge307XG4gIH1cbiAgbG9hZChjYWNoZU9iaikge1xuICAgIHRoaXMuY2FjaGUgPSB7XG4gICAgICAuLi50aGlzLmNhY2hlLFxuICAgICAgLi4uY2FjaGVPYmpcbiAgICB9O1xuICB9XG59XG5cbmNsYXNzIEV0YUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJFdGEgRXJyb3JcIjtcbiAgfVxufVxuY2xhc3MgRXRhUGFyc2VFcnJvciBleHRlbmRzIEV0YUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiRXRhUGFyc2VyIEVycm9yXCI7XG4gIH1cbn1cbmNsYXNzIEV0YVJ1bnRpbWVFcnJvciBleHRlbmRzIEV0YUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiRXRhUnVudGltZSBFcnJvclwiO1xuICB9XG59XG5jbGFzcyBFdGFGaWxlUmVzb2x1dGlvbkVycm9yIGV4dGVuZHMgRXRhRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJFdGFGaWxlUmVzb2x1dGlvbiBFcnJvclwiO1xuICB9XG59XG5jbGFzcyBFdGFOYW1lUmVzb2x1dGlvbkVycm9yIGV4dGVuZHMgRXRhRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJFdGFOYW1lUmVzb2x1dGlvbiBFcnJvclwiO1xuICB9XG59XG4vKipcbiAqIFRocm93cyBhbiBFdGFFcnJvciB3aXRoIGEgbmljZWx5IGZvcm1hdHRlZCBlcnJvciBhbmQgbWVzc2FnZSBzaG93aW5nIHdoZXJlIGluIHRoZSB0ZW1wbGF0ZSB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gKi9cbmZ1bmN0aW9uIFBhcnNlRXJyKG1lc3NhZ2UsIHN0ciwgaW5keCkge1xuICBjb25zdCB3aGl0ZXNwYWNlID0gc3RyLnNsaWNlKDAsIGluZHgpLnNwbGl0KC9cXG4vKTtcbiAgY29uc3QgbGluZU5vID0gd2hpdGVzcGFjZS5sZW5ndGg7XG4gIGNvbnN0IGNvbE5vID0gd2hpdGVzcGFjZVtsaW5lTm8gLSAxXS5sZW5ndGggKyAxO1xuICBtZXNzYWdlICs9IFwiIGF0IGxpbmUgXCIgKyBsaW5lTm8gKyBcIiBjb2wgXCIgKyBjb2xObyArIFwiOlxcblxcblwiICsgXCIgIFwiICsgc3RyLnNwbGl0KC9cXG4vKVtsaW5lTm8gLSAxXSArIFwiXFxuXCIgKyBcIiAgXCIgKyBBcnJheShjb2xObykuam9pbihcIiBcIikgKyBcIl5cIjtcbiAgdGhyb3cgbmV3IEV0YVBhcnNlRXJyb3IobWVzc2FnZSk7XG59XG5mdW5jdGlvbiBSdW50aW1lRXJyKG9yaWdpbmFsRXJyb3IsIHN0ciwgbGluZU5vLCBwYXRoKSB7XG4gIC8vIGNvZGUgZ3JhdGVmdWxseSB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tZGUvZWpzIGFuZCBhZGFwdGVkXG4gIGNvbnN0IGxpbmVzID0gc3RyLnNwbGl0KFwiXFxuXCIpO1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KGxpbmVObyAtIDMsIDApO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbihsaW5lcy5sZW5ndGgsIGxpbmVObyArIDMpO1xuICBjb25zdCBmaWxlbmFtZSA9IHBhdGg7XG4gIC8vIEVycm9yIGNvbnRleHRcbiAgY29uc3QgY29udGV4dCA9IGxpbmVzLnNsaWNlKHN0YXJ0LCBlbmQpLm1hcChmdW5jdGlvbiAobGluZSwgaSkge1xuICAgIGNvbnN0IGN1cnIgPSBpICsgc3RhcnQgKyAxO1xuICAgIHJldHVybiAoY3VyciA9PSBsaW5lTm8gPyBcIiA+PiBcIiA6IFwiICAgIFwiKSArIGN1cnIgKyBcInwgXCIgKyBsaW5lO1xuICB9KS5qb2luKFwiXFxuXCIpO1xuICBjb25zdCBoZWFkZXIgPSBmaWxlbmFtZSA/IGZpbGVuYW1lICsgXCI6XCIgKyBsaW5lTm8gKyBcIlxcblwiIDogXCJsaW5lIFwiICsgbGluZU5vICsgXCJcXG5cIjtcbiAgY29uc3QgZXJyID0gbmV3IEV0YVJ1bnRpbWVFcnJvcihoZWFkZXIgKyBjb250ZXh0ICsgXCJcXG5cXG5cIiArIG9yaWdpbmFsRXJyb3IubWVzc2FnZSk7XG4gIGVyci5uYW1lID0gb3JpZ2luYWxFcnJvci5uYW1lOyAvLyB0aGUgb3JpZ2luYWwgbmFtZSAoZS5nLiBSZWZlcmVuY2VFcnJvcikgbWF5IGJlIHVzZWZ1bFxuICB0aHJvdyBlcnI7XG59XG5cbi8qIEVORCBUWVBFUyAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IEFzeW5jRnVuY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAoKSB7fS5jb25zdHJ1Y3RvcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbi8qKlxuICogVGFrZXMgYSB0ZW1wbGF0ZSBzdHJpbmcgYW5kIHJldHVybnMgYSB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgd2l0aCAoZGF0YSwgY29uZmlnKVxuICpcbiAqIEBwYXJhbSBzdHIgLSBUaGUgdGVtcGxhdGUgc3RyaW5nXG4gKiBAcGFyYW0gY29uZmlnIC0gQSBjdXN0b20gY29uZmlndXJhdGlvbiBvYmplY3QgKG9wdGlvbmFsKVxuICovXG5mdW5jdGlvbiBjb21waWxlKHN0ciwgb3B0aW9ucykge1xuICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgLyogQVNZTkMgSEFORExJTkcgKi9cbiAgLy8gY29kZSBncmF0ZWZ1bGx5IHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21kZS9lanMgYW5kIGFkYXB0ZWRcbiAgY29uc3QgY3RvciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hc3luYyA/IEFzeW5jRnVuY3Rpb24gOiBGdW5jdGlvbjtcbiAgLyogRU5EIEFTWU5DIEhBTkRMSU5HICovXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBjdG9yKGNvbmZpZy52YXJOYW1lLCBcIm9wdGlvbnNcIiwgdGhpcy5jb21waWxlVG9TdHJpbmcuY2FsbCh0aGlzLCBzdHIsIG9wdGlvbnMpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctZnVuY1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEV0YVBhcnNlRXJyb3IoXCJCYWQgdGVtcGxhdGUgc3ludGF4XFxuXFxuXCIgKyBlLm1lc3NhZ2UgKyBcIlxcblwiICsgQXJyYXkoZS5tZXNzYWdlLmxlbmd0aCArIDEpLmpvaW4oXCI9XCIpICsgXCJcXG5cIiArIHRoaXMuY29tcGlsZVRvU3RyaW5nLmNhbGwodGhpcywgc3RyLCBvcHRpb25zKSArIFwiXFxuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxufVxuXG4vKiBUWVBFUyAqL1xuLyogRU5EIFRZUEVTICovXG4vKipcbiAqIENvbXBpbGVzIGEgdGVtcGxhdGUgc3RyaW5nIHRvIGEgZnVuY3Rpb24gc3RyaW5nLiBNb3N0IG9mdGVuIHVzZXJzIGp1c3QgdXNlIGBjb21waWxlKClgLCB3aGljaCBjYWxscyBgY29tcGlsZVRvU3RyaW5nYCBhbmQgY3JlYXRlcyBhIG5ldyBmdW5jdGlvbiB1c2luZyB0aGUgcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVUb1N0cmluZyhzdHIsIG9wdGlvbnMpIHtcbiAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gIGNvbnN0IGlzQXN5bmMgPSBvcHRpb25zICYmIG9wdGlvbnMuYXN5bmM7XG4gIGNvbnN0IGNvbXBpbGVCb2R5ID0gdGhpcy5jb21waWxlQm9keTtcbiAgY29uc3QgYnVmZmVyID0gdGhpcy5wYXJzZS5jYWxsKHRoaXMsIHN0cik7XG4gIC8vIG5vdGU6IHdoZW4gdGhlIGluY2x1ZGUgZnVuY3Rpb24gcGFzc2VzIHRocm91Z2ggb3B0aW9ucywgdGhlIG9ubHkgcGFyYW1ldGVyIHRoYXQgbWF0dGVycyBpcyB0aGUgZmlsZXBhdGggcGFyYW1ldGVyXG4gIGxldCByZXMgPSBgJHtjb25maWcuZnVuY3Rpb25IZWFkZXJ9XG5sZXQgaW5jbHVkZSA9ICh0ZW1wbGF0ZSwgZGF0YSkgPT4gdGhpcy5yZW5kZXIodGVtcGxhdGUsIGRhdGEsIG9wdGlvbnMpO1xubGV0IGluY2x1ZGVBc3luYyA9ICh0ZW1wbGF0ZSwgZGF0YSkgPT4gdGhpcy5yZW5kZXJBc3luYyh0ZW1wbGF0ZSwgZGF0YSwgb3B0aW9ucyk7XG5cbmxldCBfX2V0YSA9IHtyZXM6IFwiXCIsIGU6IHRoaXMuY29uZmlnLmVzY2FwZUZ1bmN0aW9uLCBmOiB0aGlzLmNvbmZpZy5maWx0ZXJGdW5jdGlvbiR7Y29uZmlnLmRlYnVnID8gJywgbGluZTogMSwgdGVtcGxhdGVTdHI6IFwiJyArIHN0ci5yZXBsYWNlKC9cXFxcfFwiL2csIFwiXFxcXCQmXCIpLnJlcGxhY2UoL1xcclxcbnxcXG58XFxyL2csIFwiXFxcXG5cIikgKyAnXCInIDogXCJcIn19O1xuXG5mdW5jdGlvbiBsYXlvdXQocGF0aCwgZGF0YSkge1xuICBfX2V0YS5sYXlvdXQgPSBwYXRoO1xuICBfX2V0YS5sYXlvdXREYXRhID0gZGF0YTtcbn0ke2NvbmZpZy5kZWJ1ZyA/IFwidHJ5IHtcIiA6IFwiXCJ9JHtjb25maWcudXNlV2l0aCA/IFwid2l0aChcIiArIGNvbmZpZy52YXJOYW1lICsgXCJ8fHt9KXtcIiA6IFwiXCJ9XG5cbiR7Y29tcGlsZUJvZHkuY2FsbCh0aGlzLCBidWZmZXIpfVxuaWYgKF9fZXRhLmxheW91dCkge1xuICBfX2V0YS5yZXMgPSAke2lzQXN5bmMgPyBcImF3YWl0IGluY2x1ZGVBc3luY1wiIDogXCJpbmNsdWRlXCJ9IChfX2V0YS5sYXlvdXQsIHsuLi4ke2NvbmZpZy52YXJOYW1lfSwgYm9keTogX19ldGEucmVzLCAuLi5fX2V0YS5sYXlvdXREYXRhfSk7XG59XG4ke2NvbmZpZy51c2VXaXRoID8gXCJ9XCIgOiBcIlwifSR7Y29uZmlnLmRlYnVnID8gXCJ9IGNhdGNoIChlKSB7IHRoaXMuUnVudGltZUVycihlLCBfX2V0YS50ZW1wbGF0ZVN0ciwgX19ldGEubGluZSwgb3B0aW9ucy5maWxlcGF0aCkgfVwiIDogXCJcIn1cbnJldHVybiBfX2V0YS5yZXM7XG5gO1xuICBpZiAoY29uZmlnLnBsdWdpbnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBjb25maWcucGx1Z2luc1tpXTtcbiAgICAgIGlmIChwbHVnaW4ucHJvY2Vzc0ZuU3RyaW5nKSB7XG4gICAgICAgIHJlcyA9IHBsdWdpbi5wcm9jZXNzRm5TdHJpbmcocmVzLCBjb25maWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBMb29wcyB0aHJvdWdoIHRoZSBBU1QgZ2VuZXJhdGVkIGJ5IGBwYXJzZWAgYW5kIHRyYW5zZm9ybSBlYWNoIGl0ZW0gaW50byBKUyBjYWxsc1xuICpcbiAqICoqRXhhbXBsZSoqXG4gKlxuICogYGBganNcbiAqIGxldCB0ZW1wbGF0ZUFTVCA9IFsnSGkgJywgeyB2YWw6ICdpdC5uYW1lJywgdDogJ2knIH1dXG4gKiBjb21waWxlQm9keS5jYWxsKEV0YSwgdGVtcGxhdGVBU1QpXG4gKiAvLyA9PiBcIl9fZXRhLnJlcys9J0hpICdcXG5fX2V0YS5yZXMrPV9fZXRhLmUoaXQubmFtZSlcXG5cIlxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVCb2R5KGJ1ZmYpIHtcbiAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgYnVmZkxlbmd0aCA9IGJ1ZmYubGVuZ3RoO1xuICBsZXQgcmV0dXJuU3RyID0gXCJcIjtcbiAgZm9yIChpOyBpIDwgYnVmZkxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudEJsb2NrID0gYnVmZltpXTtcbiAgICBpZiAodHlwZW9mIGN1cnJlbnRCbG9jayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3Qgc3RyID0gY3VycmVudEJsb2NrO1xuICAgICAgLy8gd2Uga25vdyBzdHJpbmcgZXhpc3RzXG4gICAgICByZXR1cm5TdHIgKz0gXCJfX2V0YS5yZXMrPSdcIiArIHN0ciArIFwiJ1xcblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gY3VycmVudEJsb2NrLnQ7IC8vIFwiclwiLCBcImVcIiwgb3IgXCJpXCJcbiAgICAgIGxldCBjb250ZW50ID0gY3VycmVudEJsb2NrLnZhbCB8fCBcIlwiO1xuICAgICAgaWYgKGNvbmZpZy5kZWJ1ZykgcmV0dXJuU3RyICs9IFwiX19ldGEubGluZT1cIiArIGN1cnJlbnRCbG9jay5saW5lTm8gKyBcIlxcblwiO1xuICAgICAgaWYgKHR5cGUgPT09IFwiclwiKSB7XG4gICAgICAgIC8vIHJhd1xuICAgICAgICBpZiAoY29uZmlnLmF1dG9GaWx0ZXIpIHtcbiAgICAgICAgICBjb250ZW50ID0gXCJfX2V0YS5mKFwiICsgY29udGVudCArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblN0ciArPSBcIl9fZXRhLnJlcys9XCIgKyBjb250ZW50ICsgXCJcXG5cIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJpXCIpIHtcbiAgICAgICAgLy8gaW50ZXJwb2xhdGVcbiAgICAgICAgaWYgKGNvbmZpZy5hdXRvRmlsdGVyKSB7XG4gICAgICAgICAgY29udGVudCA9IFwiX19ldGEuZihcIiArIGNvbnRlbnQgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmF1dG9Fc2NhcGUpIHtcbiAgICAgICAgICBjb250ZW50ID0gXCJfX2V0YS5lKFwiICsgY29udGVudCArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblN0ciArPSBcIl9fZXRhLnJlcys9XCIgKyBjb250ZW50ICsgXCJcXG5cIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJlXCIpIHtcbiAgICAgICAgLy8gZXhlY3V0ZVxuICAgICAgICByZXR1cm5TdHIgKz0gY29udGVudCArIFwiXFxuXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXR1cm5TdHI7XG59XG5cbi8qKlxuICogVGFrZXMgYSBzdHJpbmcgd2l0aGluIGEgdGVtcGxhdGUgYW5kIHRyaW1zIGl0LCBiYXNlZCBvbiB0aGUgcHJlY2VkaW5nIHRhZydzIHdoaXRlc3BhY2UgY29udHJvbCBhbmQgYGNvbmZpZy5hdXRvVHJpbWBcbiAqL1xuZnVuY3Rpb24gdHJpbVdTKHN0ciwgY29uZmlnLCB3c0xlZnQsIHdzUmlnaHQpIHtcbiAgbGV0IGxlZnRUcmltO1xuICBsZXQgcmlnaHRUcmltO1xuICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcuYXV0b1RyaW0pKSB7XG4gICAgLy8gU2xpZ2h0bHkgY29uZnVzaW5nLFxuICAgIC8vIGJ1dCBffX0gd2lsbCB0cmltIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGZvbGxvd2luZyBzdHJpbmdcbiAgICBsZWZ0VHJpbSA9IGNvbmZpZy5hdXRvVHJpbVsxXTtcbiAgICByaWdodFRyaW0gPSBjb25maWcuYXV0b1RyaW1bMF07XG4gIH0gZWxzZSB7XG4gICAgbGVmdFRyaW0gPSByaWdodFRyaW0gPSBjb25maWcuYXV0b1RyaW07XG4gIH1cbiAgaWYgKHdzTGVmdCB8fCB3c0xlZnQgPT09IGZhbHNlKSB7XG4gICAgbGVmdFRyaW0gPSB3c0xlZnQ7XG4gIH1cbiAgaWYgKHdzUmlnaHQgfHwgd3NSaWdodCA9PT0gZmFsc2UpIHtcbiAgICByaWdodFRyaW0gPSB3c1JpZ2h0O1xuICB9XG4gIGlmICghcmlnaHRUcmltICYmICFsZWZ0VHJpbSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgaWYgKGxlZnRUcmltID09PSBcInNsdXJwXCIgJiYgcmlnaHRUcmltID09PSBcInNsdXJwXCIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKTtcbiAgfVxuICBpZiAobGVmdFRyaW0gPT09IFwiX1wiIHx8IGxlZnRUcmltID09PSBcInNsdXJwXCIpIHtcbiAgICAvLyBmdWxsIHNsdXJwXG4gICAgc3RyID0gc3RyLnRyaW1TdGFydCgpO1xuICB9IGVsc2UgaWYgKGxlZnRUcmltID09PSBcIi1cIiB8fCBsZWZ0VHJpbSA9PT0gXCJubFwiKSB7XG4gICAgLy8gbmwgdHJpbVxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eKD86XFxyXFxufFxcbnxcXHIpLywgXCJcIik7XG4gIH1cbiAgaWYgKHJpZ2h0VHJpbSA9PT0gXCJfXCIgfHwgcmlnaHRUcmltID09PSBcInNsdXJwXCIpIHtcbiAgICAvLyBmdWxsIHNsdXJwXG4gICAgc3RyID0gc3RyLnRyaW1FbmQoKTtcbiAgfSBlbHNlIGlmIChyaWdodFRyaW0gPT09IFwiLVwiIHx8IHJpZ2h0VHJpbSA9PT0gXCJubFwiKSB7XG4gICAgLy8gbmwgdHJpbVxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oPzpcXHJcXG58XFxufFxccikkLywgXCJcIik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbi8qKlxuICogQSBtYXAgb2Ygc3BlY2lhbCBIVE1MIGNoYXJhY3RlcnMgdG8gdGhlaXIgWE1MLWVzY2FwZWQgZXF1aXZhbGVudHNcbiAqL1xuY29uc3QgZXNjTWFwID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiMzOTtcIlxufTtcbmZ1bmN0aW9uIHJlcGxhY2VDaGFyKHMpIHtcbiAgcmV0dXJuIGVzY01hcFtzXTtcbn1cbi8qKlxuICogWE1MLWVzY2FwZXMgYW4gaW5wdXQgdmFsdWUgYWZ0ZXIgY29udmVydGluZyBpdCB0byBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSBzdHIgLSBJbnB1dCB2YWx1ZSAodXN1YWxseSBhIHN0cmluZylcbiAqIEByZXR1cm5zIFhNTC1lc2NhcGVkIHN0cmluZ1xuICovXG5mdW5jdGlvbiBYTUxFc2NhcGUoc3RyKSB7XG4gIC8vIFRvIGRlYWwgd2l0aCBYU1MuIEJhc2VkIG9uIEVzY2FwZSBpbXBsZW1lbnRhdGlvbnMgb2YgTXVzdGFjaGUuSlMgYW5kIE1hcmtvLCB0aGVuIGN1c3RvbWl6ZWQuXG4gIGNvbnN0IG5ld1N0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoL1smPD5cIiddLy50ZXN0KG5ld1N0cikpIHtcbiAgICByZXR1cm4gbmV3U3RyLnJlcGxhY2UoL1smPD5cIiddL2csIHJlcGxhY2VDaGFyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3U3RyO1xuICB9XG59XG5cbi8qIEVORCBUWVBFUyAqL1xuLyoqIEV0YSdzIGJhc2UgKGdsb2JhbCkgY29uZmlndXJhdGlvbiAqL1xuY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgYXV0b0VzY2FwZTogdHJ1ZSxcbiAgYXV0b0ZpbHRlcjogZmFsc2UsXG4gIGF1dG9UcmltOiBbZmFsc2UsIFwibmxcIl0sXG4gIGNhY2hlOiBmYWxzZSxcbiAgY2FjaGVGaWxlcGF0aHM6IHRydWUsXG4gIGRlYnVnOiBmYWxzZSxcbiAgZXNjYXBlRnVuY3Rpb246IFhNTEVzY2FwZSxcbiAgLy8gZGVmYXVsdCBmaWx0ZXIgZnVuY3Rpb24gKG5vdCB1c2VkIHVubGVzcyBlbmFibGVzKSBqdXN0IHN0cmluZ2lmaWVzIHRoZSBpbnB1dFxuICBmaWx0ZXJGdW5jdGlvbjogdmFsID0+IFN0cmluZyh2YWwpLFxuICBmdW5jdGlvbkhlYWRlcjogXCJcIixcbiAgcGFyc2U6IHtcbiAgICBleGVjOiBcIlwiLFxuICAgIGludGVycG9sYXRlOiBcIj1cIixcbiAgICByYXc6IFwiflwiXG4gIH0sXG4gIHBsdWdpbnM6IFtdLFxuICBybVdoaXRlc3BhY2U6IGZhbHNlLFxuICB0YWdzOiBbXCI8JVwiLCBcIiU+XCJdLFxuICB1c2VXaXRoOiBmYWxzZSxcbiAgdmFyTmFtZTogXCJpdFwiLFxuICBkZWZhdWx0RXh0ZW5zaW9uOiBcIi5ldGFcIlxufTtcblxuLyogRU5EIFRZUEVTICovXG5jb25zdCB0ZW1wbGF0ZUxpdFJlZyA9IC9gKD86XFxcXFtcXHNcXFNdfFxcJHsoPzpbXnt9XXx7KD86W157fV18e1tefV0qfSkqfSkqfXwoPyFcXCR7KVteXFxcXGBdKSpgL2c7XG5jb25zdCBzaW5nbGVRdW90ZVJlZyA9IC8nKD86XFxcXFtcXHNcXHdcIidcXFxcYF18W15cXG5cXHInXFxcXF0pKj8nL2c7XG5jb25zdCBkb3VibGVRdW90ZVJlZyA9IC9cIig/OlxcXFxbXFxzXFx3XCInXFxcXGBdfFteXFxuXFxyXCJcXFxcXSkqP1wiL2c7XG4vKiogRXNjYXBlIHNwZWNpYWwgcmVndWxhciBleHByZXNzaW9uIGNoYXJhY3RlcnMgaW5zaWRlIGEgc3RyaW5nICovXG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIC8vIEZyb20gTUROXG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qK1xcLT9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpOyAvLyAkJiBtZWFucyB0aGUgd2hvbGUgbWF0Y2hlZCBzdHJpbmdcbn1cblxuZnVuY3Rpb24gZ2V0TGluZU5vKHN0ciwgaW5kZXgpIHtcbiAgcmV0dXJuIHN0ci5zbGljZSgwLCBpbmRleCkuc3BsaXQoXCJcXG5cIikubGVuZ3RoO1xufVxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICBsZXQgYnVmZmVyID0gW107XG4gIGxldCB0cmltTGVmdE9mTmV4dFN0ciA9IGZhbHNlO1xuICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgY29uc3QgcGFyc2VPcHRpb25zID0gY29uZmlnLnBhcnNlO1xuICBpZiAoY29uZmlnLnBsdWdpbnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBjb25maWcucGx1Z2luc1tpXTtcbiAgICAgIGlmIChwbHVnaW4ucHJvY2Vzc1RlbXBsYXRlKSB7XG4gICAgICAgIHN0ciA9IHBsdWdpbi5wcm9jZXNzVGVtcGxhdGUoc3RyLCBjb25maWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiBBZGRpbmcgZm9yIEVKUyBjb21wYXRpYmlsaXR5ICovXG4gIGlmIChjb25maWcucm1XaGl0ZXNwYWNlKSB7XG4gICAgLy8gQ29kZSB0YWtlbiBkaXJlY3RseSBmcm9tIEVKU1xuICAgIC8vIEhhdmUgdG8gdXNlIHR3byBzZXBhcmF0ZSByZXBsYWNlcyBoZXJlIGFzIGBeYCBhbmQgYCRgIG9wZXJhdG9ycyBkb24ndFxuICAgIC8vIHdvcmsgd2VsbCB3aXRoIGBcXHJgIGFuZCBlbXB0eSBsaW5lcyBkb24ndCB3b3JrIHdlbGwgd2l0aCB0aGUgYG1gIGZsYWcuXG4gICAgLy8gRXNzZW50aWFsbHksIHRoaXMgcmVwbGFjZXMgdGhlIHdoaXRlc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mXG4gICAgLy8gZWFjaCBsaW5lIGFuZCByZW1vdmVzIG11bHRpcGxlIG5ld2xpbmVzLlxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9bXFxyXFxuXSsvZywgXCJcXG5cIikucmVwbGFjZSgvXlxccyt8XFxzKyQvZ20sIFwiXCIpO1xuICB9XG4gIC8qIEVuZCBybVdoaXRlc3BhY2Ugb3B0aW9uICovXG4gIHRlbXBsYXRlTGl0UmVnLmxhc3RJbmRleCA9IDA7XG4gIHNpbmdsZVF1b3RlUmVnLmxhc3RJbmRleCA9IDA7XG4gIGRvdWJsZVF1b3RlUmVnLmxhc3RJbmRleCA9IDA7XG4gIGZ1bmN0aW9uIHB1c2hTdHJpbmcoc3RybmcsIHNob3VsZFRyaW1SaWdodE9mU3RyaW5nKSB7XG4gICAgaWYgKHN0cm5nKSB7XG4gICAgICAvLyBpZiBzdHJpbmcgaXMgdHJ1dGh5IGl0IG11c3QgYmUgb2YgdHlwZSAnc3RyaW5nJ1xuICAgICAgc3RybmcgPSB0cmltV1Moc3RybmcsIGNvbmZpZywgdHJpbUxlZnRPZk5leHRTdHIsXG4gICAgICAvLyB0aGlzIHdpbGwgb25seSBiZSBmYWxzZSBvbiB0aGUgZmlyc3Qgc3RyLCB0aGUgbmV4dCBvbmVzIHdpbGwgYmUgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgIHNob3VsZFRyaW1SaWdodE9mU3RyaW5nKTtcbiAgICAgIGlmIChzdHJuZykge1xuICAgICAgICAvLyByZXBsYWNlIFxcIHdpdGggXFxcXCwgJyB3aXRoIFxcJ1xuICAgICAgICAvLyB3ZSdyZSBnb2luZyB0byBjb252ZXJ0IGFsbCBDUkxGIHRvIExGIHNvIGl0IGRvZXNuJ3QgdGFrZSBtb3JlIHRoYW4gb25lIHJlcGxhY2VcbiAgICAgICAgc3RybmcgPSBzdHJuZy5yZXBsYWNlKC9cXFxcfCcvZywgXCJcXFxcJCZcIikucmVwbGFjZSgvXFxyXFxufFxcbnxcXHIvZywgXCJcXFxcblwiKTtcbiAgICAgICAgYnVmZmVyLnB1c2goc3RybmcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBwcmVmaXhlcyA9IFtwYXJzZU9wdGlvbnMuZXhlYywgcGFyc2VPcHRpb25zLmludGVycG9sYXRlLCBwYXJzZU9wdGlvbnMucmF3XS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBwcmVmaXgpIHtcbiAgICBpZiAoYWNjdW11bGF0b3IgJiYgcHJlZml4KSB7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3IgKyBcInxcIiArIGVzY2FwZVJlZ0V4cChwcmVmaXgpO1xuICAgIH0gZWxzZSBpZiAocHJlZml4KSB7XG4gICAgICAvLyBhY2N1bXVsYXRvciBpcyBmYWxzeVxuICAgICAgcmV0dXJuIGVzY2FwZVJlZ0V4cChwcmVmaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwcmVmaXggYW5kIGFjY3VtdWxhdG9yIGFyZSBib3RoIGZhbHN5XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuICB9LCBcIlwiKTtcbiAgY29uc3QgcGFyc2VPcGVuUmVnID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAoY29uZmlnLnRhZ3NbMF0pICsgXCIoLXxfKT9cXFxccyooXCIgKyBwcmVmaXhlcyArIFwiKT9cXFxccypcIiwgXCJnXCIpO1xuICBjb25zdCBwYXJzZUNsb3NlUmVnID0gbmV3IFJlZ0V4cChcIid8XFxcInxgfFxcXFwvXFxcXCp8KFxcXFxzKigtfF8pP1wiICsgZXNjYXBlUmVnRXhwKGNvbmZpZy50YWdzWzFdKSArIFwiKVwiLCBcImdcIik7XG4gIGxldCBtO1xuICB3aGlsZSAobSA9IHBhcnNlT3BlblJlZy5leGVjKHN0cikpIHtcbiAgICBjb25zdCBwcmVjZWRpbmdTdHJpbmcgPSBzdHIuc2xpY2UobGFzdEluZGV4LCBtLmluZGV4KTtcbiAgICBsYXN0SW5kZXggPSBtWzBdLmxlbmd0aCArIG0uaW5kZXg7XG4gICAgY29uc3Qgd3NMZWZ0ID0gbVsxXTtcbiAgICBjb25zdCBwcmVmaXggPSBtWzJdIHx8IFwiXCI7IC8vIGJ5IGRlZmF1bHQgZWl0aGVyIH4sID0sIG9yIGVtcHR5XG4gICAgcHVzaFN0cmluZyhwcmVjZWRpbmdTdHJpbmcsIHdzTGVmdCk7XG4gICAgcGFyc2VDbG9zZVJlZy5sYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgbGV0IGNsb3NlVGFnO1xuICAgIGxldCBjdXJyZW50T2JqID0gZmFsc2U7XG4gICAgd2hpbGUgKGNsb3NlVGFnID0gcGFyc2VDbG9zZVJlZy5leGVjKHN0cikpIHtcbiAgICAgIGlmIChjbG9zZVRhZ1sxXSkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gc3RyLnNsaWNlKGxhc3RJbmRleCwgY2xvc2VUYWcuaW5kZXgpO1xuICAgICAgICBwYXJzZU9wZW5SZWcubGFzdEluZGV4ID0gbGFzdEluZGV4ID0gcGFyc2VDbG9zZVJlZy5sYXN0SW5kZXg7XG4gICAgICAgIHRyaW1MZWZ0T2ZOZXh0U3RyID0gY2xvc2VUYWdbMl07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUeXBlID0gcHJlZml4ID09PSBwYXJzZU9wdGlvbnMuZXhlYyA/IFwiZVwiIDogcHJlZml4ID09PSBwYXJzZU9wdGlvbnMucmF3ID8gXCJyXCIgOiBwcmVmaXggPT09IHBhcnNlT3B0aW9ucy5pbnRlcnBvbGF0ZSA/IFwiaVwiIDogXCJcIjtcbiAgICAgICAgY3VycmVudE9iaiA9IHtcbiAgICAgICAgICB0OiBjdXJyZW50VHlwZSxcbiAgICAgICAgICB2YWw6IGNvbnRlbnRcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjaGFyID0gY2xvc2VUYWdbMF07XG4gICAgICAgIGlmIChjaGFyID09PSBcIi8qXCIpIHtcbiAgICAgICAgICBjb25zdCBjb21tZW50Q2xvc2VJbmQgPSBzdHIuaW5kZXhPZihcIiovXCIsIHBhcnNlQ2xvc2VSZWcubGFzdEluZGV4KTtcbiAgICAgICAgICBpZiAoY29tbWVudENsb3NlSW5kID09PSAtMSkge1xuICAgICAgICAgICAgUGFyc2VFcnIoXCJ1bmNsb3NlZCBjb21tZW50XCIsIHN0ciwgY2xvc2VUYWcuaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJzZUNsb3NlUmVnLmxhc3RJbmRleCA9IGNvbW1lbnRDbG9zZUluZDtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBcIidcIikge1xuICAgICAgICAgIHNpbmdsZVF1b3RlUmVnLmxhc3RJbmRleCA9IGNsb3NlVGFnLmluZGV4O1xuICAgICAgICAgIGNvbnN0IHNpbmdsZVF1b3RlTWF0Y2ggPSBzaW5nbGVRdW90ZVJlZy5leGVjKHN0cik7XG4gICAgICAgICAgaWYgKHNpbmdsZVF1b3RlTWF0Y2gpIHtcbiAgICAgICAgICAgIHBhcnNlQ2xvc2VSZWcubGFzdEluZGV4ID0gc2luZ2xlUXVvdGVSZWcubGFzdEluZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBQYXJzZUVycihcInVuY2xvc2VkIHN0cmluZ1wiLCBzdHIsIGNsb3NlVGFnLmluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ1wiJykge1xuICAgICAgICAgIGRvdWJsZVF1b3RlUmVnLmxhc3RJbmRleCA9IGNsb3NlVGFnLmluZGV4O1xuICAgICAgICAgIGNvbnN0IGRvdWJsZVF1b3RlTWF0Y2ggPSBkb3VibGVRdW90ZVJlZy5leGVjKHN0cik7XG4gICAgICAgICAgaWYgKGRvdWJsZVF1b3RlTWF0Y2gpIHtcbiAgICAgICAgICAgIHBhcnNlQ2xvc2VSZWcubGFzdEluZGV4ID0gZG91YmxlUXVvdGVSZWcubGFzdEluZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBQYXJzZUVycihcInVuY2xvc2VkIHN0cmluZ1wiLCBzdHIsIGNsb3NlVGFnLmluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gXCJgXCIpIHtcbiAgICAgICAgICB0ZW1wbGF0ZUxpdFJlZy5sYXN0SW5kZXggPSBjbG9zZVRhZy5pbmRleDtcbiAgICAgICAgICBjb25zdCB0ZW1wbGF0ZUxpdE1hdGNoID0gdGVtcGxhdGVMaXRSZWcuZXhlYyhzdHIpO1xuICAgICAgICAgIGlmICh0ZW1wbGF0ZUxpdE1hdGNoKSB7XG4gICAgICAgICAgICBwYXJzZUNsb3NlUmVnLmxhc3RJbmRleCA9IHRlbXBsYXRlTGl0UmVnLmxhc3RJbmRleDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUGFyc2VFcnIoXCJ1bmNsb3NlZCBzdHJpbmdcIiwgc3RyLCBjbG9zZVRhZy5pbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50T2JqKSB7XG4gICAgICBpZiAoY29uZmlnLmRlYnVnKSB7XG4gICAgICAgIGN1cnJlbnRPYmoubGluZU5vID0gZ2V0TGluZU5vKHN0ciwgbS5pbmRleCk7XG4gICAgICB9XG4gICAgICBidWZmZXIucHVzaChjdXJyZW50T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUGFyc2VFcnIoXCJ1bmNsb3NlZCB0YWdcIiwgc3RyLCBtLmluZGV4KTtcbiAgICB9XG4gIH1cbiAgcHVzaFN0cmluZyhzdHIuc2xpY2UobGFzdEluZGV4LCBzdHIubGVuZ3RoKSwgZmFsc2UpO1xuICBpZiAoY29uZmlnLnBsdWdpbnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBjb25maWcucGx1Z2luc1tpXTtcbiAgICAgIGlmIChwbHVnaW4ucHJvY2Vzc0FTVCkge1xuICAgICAgICBidWZmZXIgPSBwbHVnaW4ucHJvY2Vzc0FTVChidWZmZXIsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5cbi8qIEVORCBUWVBFUyAqL1xuZnVuY3Rpb24gaGFuZGxlQ2FjaGUodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgdGVtcGxhdGVTdG9yZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hc3luYyA/IHRoaXMudGVtcGxhdGVzQXN5bmMgOiB0aGlzLnRlbXBsYXRlc1N5bmM7XG4gIGlmICh0aGlzLnJlc29sdmVQYXRoICYmIHRoaXMucmVhZEZpbGUgJiYgIXRlbXBsYXRlLnN0YXJ0c1dpdGgoXCJAXCIpKSB7XG4gICAgY29uc3QgdGVtcGxhdGVQYXRoID0gb3B0aW9ucy5maWxlcGF0aDtcbiAgICBjb25zdCBjYWNoZWRUZW1wbGF0ZSA9IHRlbXBsYXRlU3RvcmUuZ2V0KHRlbXBsYXRlUGF0aCk7XG4gICAgaWYgKHRoaXMuY29uZmlnLmNhY2hlICYmIGNhY2hlZFRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkVGVtcGxhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlU3RyaW5nID0gdGhpcy5yZWFkRmlsZSh0ZW1wbGF0ZVBhdGgpO1xuICAgICAgY29uc3QgdGVtcGxhdGVGbiA9IHRoaXMuY29tcGlsZSh0ZW1wbGF0ZVN0cmluZywgb3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5jb25maWcuY2FjaGUpIHRlbXBsYXRlU3RvcmUuZGVmaW5lKHRlbXBsYXRlUGF0aCwgdGVtcGxhdGVGbik7XG4gICAgICByZXR1cm4gdGVtcGxhdGVGbjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2FjaGVkVGVtcGxhdGUgPSB0ZW1wbGF0ZVN0b3JlLmdldCh0ZW1wbGF0ZSk7XG4gICAgaWYgKGNhY2hlZFRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkVGVtcGxhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFdGFOYW1lUmVzb2x1dGlvbkVycm9yKFwiRmFpbGVkIHRvIGdldCB0ZW1wbGF0ZSAnXCIgKyB0ZW1wbGF0ZSArIFwiJ1wiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbmRlcih0ZW1wbGF0ZSxcbi8vIHRlbXBsYXRlIG5hbWUgb3IgdGVtcGxhdGUgZnVuY3Rpb25cbmRhdGEsIG1ldGEpIHtcbiAgbGV0IHRlbXBsYXRlRm47XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4ubWV0YSxcbiAgICBhc3luYzogZmFsc2VcbiAgfTtcbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmICh0aGlzLnJlc29sdmVQYXRoICYmIHRoaXMucmVhZEZpbGUgJiYgIXRlbXBsYXRlLnN0YXJ0c1dpdGgoXCJAXCIpKSB7XG4gICAgICBvcHRpb25zLmZpbGVwYXRoID0gdGhpcy5yZXNvbHZlUGF0aCh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRlbXBsYXRlRm4gPSBoYW5kbGVDYWNoZS5jYWxsKHRoaXMsIHRlbXBsYXRlLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZUZuID0gdGVtcGxhdGU7XG4gIH1cbiAgY29uc3QgcmVzID0gdGVtcGxhdGVGbi5jYWxsKHRoaXMsIGRhdGEsIG9wdGlvbnMpO1xuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gcmVuZGVyQXN5bmModGVtcGxhdGUsXG4vLyB0ZW1wbGF0ZSBuYW1lIG9yIHRlbXBsYXRlIGZ1bmN0aW9uXG5kYXRhLCBtZXRhKSB7XG4gIGxldCB0ZW1wbGF0ZUZuO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLm1ldGEsXG4gICAgYXN5bmM6IHRydWVcbiAgfTtcbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmICh0aGlzLnJlc29sdmVQYXRoICYmIHRoaXMucmVhZEZpbGUgJiYgIXRlbXBsYXRlLnN0YXJ0c1dpdGgoXCJAXCIpKSB7XG4gICAgICBvcHRpb25zLmZpbGVwYXRoID0gdGhpcy5yZXNvbHZlUGF0aCh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRlbXBsYXRlRm4gPSBoYW5kbGVDYWNoZS5jYWxsKHRoaXMsIHRlbXBsYXRlLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZUZuID0gdGVtcGxhdGU7XG4gIH1cbiAgY29uc3QgcmVzID0gdGVtcGxhdGVGbi5jYWxsKHRoaXMsIGRhdGEsIG9wdGlvbnMpO1xuICAvLyBSZXR1cm4gYSBwcm9taXNlXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzKTtcbn1cbmZ1bmN0aW9uIHJlbmRlclN0cmluZyh0ZW1wbGF0ZSwgZGF0YSkge1xuICBjb25zdCB0ZW1wbGF0ZUZuID0gdGhpcy5jb21waWxlKHRlbXBsYXRlLCB7XG4gICAgYXN5bmM6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgdGVtcGxhdGVGbiwgZGF0YSk7XG59XG5mdW5jdGlvbiByZW5kZXJTdHJpbmdBc3luYyh0ZW1wbGF0ZSwgZGF0YSkge1xuICBjb25zdCB0ZW1wbGF0ZUZuID0gdGhpcy5jb21waWxlKHRlbXBsYXRlLCB7XG4gICAgYXN5bmM6IHRydWVcbiAgfSk7XG4gIHJldHVybiByZW5kZXJBc3luYy5jYWxsKHRoaXMsIHRlbXBsYXRlRm4sIGRhdGEpO1xufVxuXG4vKiBFTkQgVFlQRVMgKi9cbmNsYXNzIEV0YSQxIHtcbiAgY29uc3RydWN0b3IoY3VzdG9tQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5SdW50aW1lRXJyID0gUnVudGltZUVycjtcbiAgICB0aGlzLmNvbXBpbGUgPSBjb21waWxlO1xuICAgIHRoaXMuY29tcGlsZVRvU3RyaW5nID0gY29tcGlsZVRvU3RyaW5nO1xuICAgIHRoaXMuY29tcGlsZUJvZHkgPSBjb21waWxlQm9keTtcbiAgICB0aGlzLnBhcnNlID0gcGFyc2U7XG4gICAgdGhpcy5yZW5kZXIgPSByZW5kZXI7XG4gICAgdGhpcy5yZW5kZXJBc3luYyA9IHJlbmRlckFzeW5jO1xuICAgIHRoaXMucmVuZGVyU3RyaW5nID0gcmVuZGVyU3RyaW5nO1xuICAgIHRoaXMucmVuZGVyU3RyaW5nQXN5bmMgPSByZW5kZXJTdHJpbmdBc3luYztcbiAgICB0aGlzLmZpbGVwYXRoQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnRlbXBsYXRlc1N5bmMgPSBuZXcgQ2FjaGVyKHt9KTtcbiAgICB0aGlzLnRlbXBsYXRlc0FzeW5jID0gbmV3IENhY2hlcih7fSk7XG4gICAgLy8gcmVzb2x2ZVBhdGggdGFrZXMgYSByZWxhdGl2ZSBwYXRoIGZyb20gdGhlIFwidmlld3NcIiBkaXJlY3RvcnlcbiAgICB0aGlzLnJlc29sdmVQYXRoID0gbnVsbDtcbiAgICB0aGlzLnJlYWRGaWxlID0gbnVsbDtcbiAgICBpZiAoY3VzdG9tQ29uZmlnKSB7XG4gICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgLi4uZGVmYXVsdENvbmZpZyxcbiAgICAgICAgLi4uY3VzdG9tQ29uZmlnXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgLi4uZGVmYXVsdENvbmZpZ1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLy8gTUVUSE9EU1xuICBjb25maWd1cmUoY3VzdG9tQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIC4uLmN1c3RvbUNvbmZpZ1xuICAgIH07XG4gIH1cbiAgd2l0aENvbmZpZyhjdXN0b21Db25maWcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcyxcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgLi4uY3VzdG9tQ29uZmlnXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBsb2FkVGVtcGxhdGUobmFtZSwgdGVtcGxhdGUsXG4gIC8vIHRlbXBsYXRlIHN0cmluZyBvciB0ZW1wbGF0ZSBmdW5jdGlvblxuICBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgdGVtcGxhdGVzID0gb3B0aW9ucyAmJiBvcHRpb25zLmFzeW5jID8gdGhpcy50ZW1wbGF0ZXNBc3luYyA6IHRoaXMudGVtcGxhdGVzU3luYztcbiAgICAgIHRlbXBsYXRlcy5kZWZpbmUobmFtZSwgdGhpcy5jb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB0ZW1wbGF0ZXMgPSB0aGlzLnRlbXBsYXRlc1N5bmM7XG4gICAgICBpZiAodGVtcGxhdGUuY29uc3RydWN0b3IubmFtZSA9PT0gXCJBc3luY0Z1bmN0aW9uXCIgfHwgb3B0aW9ucyAmJiBvcHRpb25zLmFzeW5jKSB7XG4gICAgICAgIHRlbXBsYXRlcyA9IHRoaXMudGVtcGxhdGVzQXN5bmM7XG4gICAgICB9XG4gICAgICB0ZW1wbGF0ZXMuZGVmaW5lKG5hbWUsIHRlbXBsYXRlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogRU5EIFRZUEVTICovXG5mdW5jdGlvbiByZWFkRmlsZShwYXRoKSB7XG4gIGxldCByZXMgPSBcIlwiO1xuICB0cnkge1xuICAgIHJlcyA9IGZzLnJlYWRGaWxlU3luYyhwYXRoLCBcInV0ZjhcIik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICgoZXJyID09IG51bGwgPyB2b2lkIDAgOiBlcnIuY29kZSkgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgIHRocm93IG5ldyBFdGFGaWxlUmVzb2x1dGlvbkVycm9yKGBDb3VsZCBub3QgZmluZCB0ZW1wbGF0ZTogJHtwYXRofWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiByZXNvbHZlUGF0aCh0ZW1wbGF0ZVBhdGgsIG9wdGlvbnMpIHtcbiAgbGV0IHJlc29sdmVkRmlsZVBhdGggPSBcIlwiO1xuICBjb25zdCB2aWV3cyA9IHRoaXMuY29uZmlnLnZpZXdzO1xuICBpZiAoIXZpZXdzKSB7XG4gICAgdGhyb3cgbmV3IEV0YUZpbGVSZXNvbHV0aW9uRXJyb3IoXCJWaWV3cyBkaXJlY3RvcnkgaXMgbm90IGRlZmluZWRcIik7XG4gIH1cbiAgY29uc3QgYmFzZUZpbGVQYXRoID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbGVwYXRoO1xuICBjb25zdCBkZWZhdWx0RXh0ZW5zaW9uID0gdGhpcy5jb25maWcuZGVmYXVsdEV4dGVuc2lvbiA9PT0gdW5kZWZpbmVkID8gXCIuZXRhXCIgOiB0aGlzLmNvbmZpZy5kZWZhdWx0RXh0ZW5zaW9uO1xuICAvLyBob3cgd2UgaW5kZXggY2FjaGVkIHRlbXBsYXRlIHBhdGhzXG4gIGNvbnN0IGNhY2hlSW5kZXggPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgZmlsZW5hbWU6IGJhc2VGaWxlUGF0aCxcbiAgICBwYXRoOiB0ZW1wbGF0ZVBhdGgsXG4gICAgdmlld3M6IHRoaXMuY29uZmlnLnZpZXdzXG4gIH0pO1xuICB0ZW1wbGF0ZVBhdGggKz0gcGF0aC5leHRuYW1lKHRlbXBsYXRlUGF0aCkgPyBcIlwiIDogZGVmYXVsdEV4dGVuc2lvbjtcbiAgLy8gaWYgdGhlIGZpbGUgd2FzIGluY2x1ZGVkIGZyb20gYW5vdGhlciB0ZW1wbGF0ZVxuICBpZiAoYmFzZUZpbGVQYXRoKSB7XG4gICAgLy8gY2hlY2sgdGhlIGNhY2hlXG4gICAgaWYgKHRoaXMuY29uZmlnLmNhY2hlRmlsZXBhdGhzICYmIHRoaXMuZmlsZXBhdGhDYWNoZVtjYWNoZUluZGV4XSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsZXBhdGhDYWNoZVtjYWNoZUluZGV4XTtcbiAgICB9XG4gICAgY29uc3QgYWJzb2x1dGVQYXRoVGVzdCA9IGFic29sdXRlUGF0aFJlZ0V4cC5leGVjKHRlbXBsYXRlUGF0aCk7XG4gICAgaWYgKGFic29sdXRlUGF0aFRlc3QgJiYgYWJzb2x1dGVQYXRoVGVzdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZFBhdGggPSB0ZW1wbGF0ZVBhdGgucmVwbGFjZSgvXlxcLyp8XlxcXFwqLywgXCJcIik7XG4gICAgICByZXNvbHZlZEZpbGVQYXRoID0gcGF0aC5qb2luKHZpZXdzLCBmb3JtYXR0ZWRQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZWRGaWxlUGF0aCA9IHBhdGguam9pbihwYXRoLmRpcm5hbWUoYmFzZUZpbGVQYXRoKSwgdGVtcGxhdGVQYXRoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWRGaWxlUGF0aCA9IHBhdGguam9pbih2aWV3cywgdGVtcGxhdGVQYXRoKTtcbiAgfVxuICBpZiAoZGlySXNDaGlsZCh2aWV3cywgcmVzb2x2ZWRGaWxlUGF0aCkpIHtcbiAgICAvLyBhZGQgcmVzb2x2ZWQgcGF0aCB0byB0aGUgY2FjaGVcbiAgICBpZiAoYmFzZUZpbGVQYXRoICYmIHRoaXMuY29uZmlnLmNhY2hlRmlsZXBhdGhzKSB7XG4gICAgICB0aGlzLmZpbGVwYXRoQ2FjaGVbY2FjaGVJbmRleF0gPSByZXNvbHZlZEZpbGVQYXRoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWRGaWxlUGF0aDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXRhRmlsZVJlc29sdXRpb25FcnJvcihgVGVtcGxhdGUgJyR7dGVtcGxhdGVQYXRofScgaXMgbm90IGluIHRoZSB2aWV3cyBkaXJlY3RvcnlgKTtcbiAgfVxufVxuZnVuY3Rpb24gZGlySXNDaGlsZChwYXJlbnQsIGRpcikge1xuICBjb25zdCByZWxhdGl2ZSA9IHBhdGgucmVsYXRpdmUocGFyZW50LCBkaXIpO1xuICByZXR1cm4gcmVsYXRpdmUgJiYgIXJlbGF0aXZlLnN0YXJ0c1dpdGgoXCIuLlwiKSAmJiAhcGF0aC5pc0Fic29sdXRlKHJlbGF0aXZlKTtcbn1cbmNvbnN0IGFic29sdXRlUGF0aFJlZ0V4cCA9IC9eXFxcXHxeXFwvLztcblxuY2xhc3MgRXRhIGV4dGVuZHMgRXRhJDEge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5yZWFkRmlsZSA9IHJlYWRGaWxlO1xuICAgIHRoaXMucmVzb2x2ZVBhdGggPSByZXNvbHZlUGF0aDtcbiAgfVxufVxuXG5leHBvcnQgeyBFdGEsIEV0YUVycm9yLCBFdGFGaWxlUmVzb2x1dGlvbkVycm9yLCBFdGFOYW1lUmVzb2x1dGlvbkVycm9yLCBFdGFQYXJzZUVycm9yLCBFdGFSdW50aW1lRXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV0YS5tb2R1bGUubWpzLm1hcFxuIl0sIm5hbWVzIjpbInBhdGgiLCJmcyIsIkNhY2hlciIsImNvbnN0cnVjdG9yIiwiY2FjaGUiLCJkZWZpbmUiLCJrZXkiLCJ2YWwiLCJnZXQiLCJyZW1vdmUiLCJyZXNldCIsImxvYWQiLCJjYWNoZU9iaiIsIkV0YUVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwibmFtZSIsIkV0YVBhcnNlRXJyb3IiLCJFdGFSdW50aW1lRXJyb3IiLCJFdGFGaWxlUmVzb2x1dGlvbkVycm9yIiwiRXRhTmFtZVJlc29sdXRpb25FcnJvciIsIlBhcnNlRXJyIiwic3RyIiwiaW5keCIsIndoaXRlc3BhY2UiLCJzbGljZSIsInNwbGl0IiwibGluZU5vIiwibGVuZ3RoIiwiY29sTm8iLCJBcnJheSIsImpvaW4iLCJSdW50aW1lRXJyIiwib3JpZ2luYWxFcnJvciIsImxpbmVzIiwic3RhcnQiLCJNYXRoIiwibWF4IiwiZW5kIiwibWluIiwiZmlsZW5hbWUiLCJjb250ZXh0IiwibWFwIiwibGluZSIsImkiLCJjdXJyIiwiaGVhZGVyIiwiZXJyIiwiQXN5bmNGdW5jdGlvbiIsImNvbXBpbGUiLCJvcHRpb25zIiwiY29uZmlnIiwiY3RvciIsImFzeW5jIiwiRnVuY3Rpb24iLCJ2YXJOYW1lIiwiY29tcGlsZVRvU3RyaW5nIiwiY2FsbCIsImUiLCJTeW50YXhFcnJvciIsImlzQXN5bmMiLCJjb21waWxlQm9keSIsImJ1ZmZlciIsInBhcnNlIiwicmVzIiwiZnVuY3Rpb25IZWFkZXIiLCJkZWJ1ZyIsInJlcGxhY2UiLCJ1c2VXaXRoIiwicGx1Z2lucyIsInBsdWdpbiIsInByb2Nlc3NGblN0cmluZyIsImJ1ZmYiLCJidWZmTGVuZ3RoIiwicmV0dXJuU3RyIiwiY3VycmVudEJsb2NrIiwidHlwZSIsInQiLCJjb250ZW50IiwiYXV0b0ZpbHRlciIsImF1dG9Fc2NhcGUiLCJ0cmltV1MiLCJ3c0xlZnQiLCJ3c1JpZ2h0IiwibGVmdFRyaW0iLCJyaWdodFRyaW0iLCJpc0FycmF5IiwiYXV0b1RyaW0iLCJ0cmltIiwidHJpbVN0YXJ0IiwidHJpbUVuZCIsImVzY01hcCIsInJlcGxhY2VDaGFyIiwicyIsIlhNTEVzY2FwZSIsIm5ld1N0ciIsIlN0cmluZyIsInRlc3QiLCJkZWZhdWx0Q29uZmlnIiwiY2FjaGVGaWxlcGF0aHMiLCJlc2NhcGVGdW5jdGlvbiIsImZpbHRlckZ1bmN0aW9uIiwiZXhlYyIsImludGVycG9sYXRlIiwicmF3Iiwicm1XaGl0ZXNwYWNlIiwidGFncyIsImRlZmF1bHRFeHRlbnNpb24iLCJ0ZW1wbGF0ZUxpdFJlZyIsInNpbmdsZVF1b3RlUmVnIiwiZG91YmxlUXVvdGVSZWciLCJlc2NhcGVSZWdFeHAiLCJzdHJpbmciLCJnZXRMaW5lTm8iLCJpbmRleCIsInRyaW1MZWZ0T2ZOZXh0U3RyIiwibGFzdEluZGV4IiwicGFyc2VPcHRpb25zIiwicHJvY2Vzc1RlbXBsYXRlIiwicHVzaFN0cmluZyIsInN0cm5nIiwic2hvdWxkVHJpbVJpZ2h0T2ZTdHJpbmciLCJwdXNoIiwicHJlZml4ZXMiLCJyZWR1Y2UiLCJhY2N1bXVsYXRvciIsInByZWZpeCIsInBhcnNlT3BlblJlZyIsIlJlZ0V4cCIsInBhcnNlQ2xvc2VSZWciLCJtIiwicHJlY2VkaW5nU3RyaW5nIiwiY2xvc2VUYWciLCJjdXJyZW50T2JqIiwiY3VycmVudFR5cGUiLCJjaGFyIiwiY29tbWVudENsb3NlSW5kIiwiaW5kZXhPZiIsInNpbmdsZVF1b3RlTWF0Y2giLCJkb3VibGVRdW90ZU1hdGNoIiwidGVtcGxhdGVMaXRNYXRjaCIsInByb2Nlc3NBU1QiLCJoYW5kbGVDYWNoZSIsInRlbXBsYXRlIiwidGVtcGxhdGVTdG9yZSIsInRlbXBsYXRlc0FzeW5jIiwidGVtcGxhdGVzU3luYyIsInJlc29sdmVQYXRoIiwicmVhZEZpbGUiLCJzdGFydHNXaXRoIiwidGVtcGxhdGVQYXRoIiwiZmlsZXBhdGgiLCJjYWNoZWRUZW1wbGF0ZSIsInRlbXBsYXRlU3RyaW5nIiwidGVtcGxhdGVGbiIsInJlbmRlciIsImRhdGEiLCJtZXRhIiwicmVuZGVyQXN5bmMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlbmRlclN0cmluZyIsInJlbmRlclN0cmluZ0FzeW5jIiwiRXRhJDEiLCJjdXN0b21Db25maWciLCJmaWxlcGF0aENhY2hlIiwiY29uZmlndXJlIiwid2l0aENvbmZpZyIsImxvYWRUZW1wbGF0ZSIsInRlbXBsYXRlcyIsInJlYWRGaWxlU3luYyIsImNvZGUiLCJyZXNvbHZlZEZpbGVQYXRoIiwidmlld3MiLCJiYXNlRmlsZVBhdGgiLCJ1bmRlZmluZWQiLCJjYWNoZUluZGV4IiwiSlNPTiIsInN0cmluZ2lmeSIsImV4dG5hbWUiLCJhYnNvbHV0ZVBhdGhUZXN0IiwiYWJzb2x1dGVQYXRoUmVnRXhwIiwiZm9ybWF0dGVkUGF0aCIsImRpcm5hbWUiLCJkaXJJc0NoaWxkIiwicGFyZW50IiwiZGlyIiwicmVsYXRpdmUiLCJpc0Fic29sdXRlIiwiRXRhIiwiYXJncyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/eta@3.5.0/node_modules/eta/dist/eta.module.mjs\n");

/***/ })

};
;